---
layout: single
title: "[이것이 취업을 위한 컴퓨터 과학이다] 5-4 ~ 5-7"
categories:
  - study
sidebar:
  nav: "sidebar-category"
---

## 5 - 4. 전송 계층 - TCP와 UDP
**TCP와 UDP의 목적과 특징**
- 네트워크 상에서 호스트가 실행하는 프로세스는 포트 번호를 통해 식별할 수 있음
- 포트를 통한 프로세스 식별은 전송 계층의 주된 목적
  - 잘 알려진 포트 0 ~ 1023
  - 등록된 포트 1024 ~ 49151
    - 1194 - OpenVPN
    - 1433 - Microsoft SQL Server DB
    - 3306 - MySQL DB
    - 6379 - Redis
    - 8080 - HTTP 대체
  - 동적 포트 49152 ~ 65535
- TCP를 통해 신뢰할 수 있는 연결형 프로토콜
  - 상태관리, 흐름 제어, 오류 제어, 혼잡 제어 제공. 연결 수립, 종료 과정 있음
  - 시간과 연산이 소요되기 때문에 일반적으로 송수신 속도가 느림
    - 헤더
      - UDP 헤더에 있는 모든 필드
      - 순서 번호 필드 - TCP 패킷의 올바른 송수신 순서를 보장하기 위해 세그먼트 첫 바이트에 매겨진 번호
      - 확인 응답 번호 필드 - 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하길 기대하는 순서 번호
      - 제어 비트 ( 플래그 비트 ) - 기본적으로 8비트로 구성. 각 자리에 비트가 각기 다른 의미를 가짐
        - ACK - 세그먼트의 승인을 나타내기 위한 비트
        - SYN - 연결을 수립하기 위한 비트
        - FIN - 연결을 종료하기 위한 비트
- UDP를 통해 신뢰할 수 없는 비연결형 프로토콜
  - TCP 있는 거 다 없음
  - 패킷의 유실이 발생할 수 있음
  - 헤더
    - 송신지 포트 - 송신 프로세스가 할당된 포트 번호가 명시됨
    - 수신지 포트 - 수신 프로세스가 할당된 포트 번호가 명시됨
    - 길이 - 헤더를 포함한 UDP 패킷의 바이트 크기가 명시됨
    - 체크섬 - 송수신 과정에서의 데이터그램 훼손 여부를 알 수 있는 정보가 명시됨

**TCP의 연결부터 종료까지**
- TCP는 UDP와 달리 송수신 이전에 연결을 수립하고, 송수신 이후에는 연결을 종료함
- 연결 수립 - 쓰리 웨이 핸드셰이크
  - [송수신 방향 A → B] SYN 세그먼트 전송 - 액티브 오픈 ( 클라이언트 )
    - SYN 비트가 1로 설정된 세그먼트를 전송
    - 세그먼트의 순서 번호에는 호스트 A의 순서 번호가 포함되어 있음
- [송수신 방향 B → A] SYN + ACK 세그먼트 전송 - 패시브 오픈 ( 서버 )
  - 위 전송에 대한 호스트 B의 응답
  - 호스트 B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트를 호스트 A에게 전송
  - 세그먼트의 순서 번호에는 호스트 B의 순서 번호와 위에서 보낸 세그먼트에 대한 확인 응답 번호가 포함되어 있음
- [송수신 방향 A → B] ACK 세그먼트 전송
  - 호스트 A는 ACK 비트가 1로 설정된 세그먼트를 호스트 B에게 전송
  - 세그먼트의 순서 번호에는 호스트 A의 순서 번호와 위에서 보낸 세그먼트에 대한 확인 응답 번호가 포함되어 있음
- 송수신하는 패킷의 신뢰성을 보장하기 위해 제공하는 기능
  - 재전송을 통한 오류 제어
    - 송수신 과정에서 잘못 전송된 세그먼트가 있을 경우, 이를 재전송하여 오류를 제어함
    - 중복된 ACK 세그먼트가 도착했을 때, 타임아웃이 발생했을 때
  - 흐름 제어
    - 수신 호스트가 한 번에 받아 처리할 수 있을 만큼만 전송하는 것
    - 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능
    - 윈도우 필드 - 수신 호스트가 한 번에 처리할 수 있는 수신 윈도우 크기가 명시됨
  - 혼잡 제어
    - 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황을 제어하기 위한 기능
    - 중복된 ACK 세그먼트가 도착했을 때, 타임아웃이 발생했을 때 혼잡할 수 있다 판단
    - 혼잡 윈도우 - 혼잡 없이 전송할 수 있을 정도의 양. 송신 호스트가 직접 계산해야됨
    - 혼잡 제어 알고리즘 - 혼잡 제어를 수행하는 일련의 과정
      - AIMD - 세그먼트를 보내고, 그에 대한 응답이 오기까지(RTT) 혼잡이 감지되지 않으면 혼잡 윈도우를 1씩 선형적으로 증가시키고, 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘
- 연결 종료 - 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받으며 이루어짐
  - [송수신 방향 A → B] FIN 세그먼트 - 호스트 A는 FIN 세그먼트를 호스트 B에게 전송 ( 액티브 클로즈 )
  - [송수신 방향 B → A] ACK 세그먼트 - 위 전송에 대한 호스트 B의 응답. 호스트 B는 ACK 세그먼트를 호스트 A에게 전송
  - [송수신 방향 B → A] FIN 세그먼트 - 호스트 B는 FIN 세그먼트를 호스트 A에게 전송 ( 패시브 클로즈 )
  - [송수신 방향 A → B] ACK 세그먼트 - 위 전송에 대한 호스트 A의 응답. 호스트 A는 ACK 세그먼트를 호스트 B에게 전송
 
**TCP의 상태 관리**
- 스테이트풀 프로토콜 - 상태를 유지하고 관리하는 프로토콜
- 상태 - 현재 어떤 통신 과정에 있는지를 나타내는 정보
  - 연결이 수립되지 않았을 때 주로 활용되는 상태
    - CLOSED - 아무런 연결이 없는 상태
    - LISTEN - 연결 대기 상태
  - 연결 수립 과정에서 주로 활용되는 상태
    - SYN-SENT - SYN 세그먼트를 보낸 뒤, SYN + ACK 세그먼트를 기다리는 상태
    - SYN_RECEIVED - SYN + ACK 세그먼트를 보낸 뒤, ACK 세그먼트를 기다리는 상태
    - ESTABLISHED - 쓰리 웨이 핸드셰이크가 끝난 뒤 데이터를 송수신할 수 있는 상태
  - 연결 종료 과정에서 주로 활용되는 상태
    - FIN-WAIT-1 - 액티브 클로즈 호스트가 FIN 세그먼트로 연결 종료 요청을 보낸 상태
    - CLOSE-WAIT - FIN 세그먼트를 받은 패시브 글로즈 호스트가 응답으로 ACK 세그먼트를 보내고 대기하는 상태
    - FIN-WAIT-2 - FIN-WAIT-1 상태에서 ACK 세그먼트를 받은 상태
    - LAST-ACK - CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 대기하는 상태
    - TIME-WAIT - 액티브 클로즈 호스트가 마지막 ACK 세그먼트를 전송한 뒤 접어드는 상태
 
## 5 - 5. 응용 계층 - HTTP의 기초
**DNS와 URI/URL**
- 도메인 네임 - IP 주소로는 특정 호스트의 특징을 나타내기 어렵고, 언제든 바뀔 수 있기에 사용하는 것
  - 루트 도메인 (최상위 도메인) - com, net, org, kr, jp, cn, us 등
  - 2단계 도메인(세컨드 레벨 도메인) 
  - 전체 주소 도메인 - www.example.com 
  - 도메인 네임은 계층적인 형태를 띰
- 네임 서버
  - 도메인 네임과 그에 대응하는 IP 주소를 관리하는 서버
  - 도메인 네임이 계층적이기 때문에 그를 관리하는 네임 서버도 계층적
- DNS 서버 - 도메인 네임을 관리하는 네임 서버
- 도메인 네임 시스템(DNS)
  - 계층적으로 분산되어 있는 도메인 네임에 대한 관리 체계
  - DNS는 호스트가 이러한 DNS를 이용할 수 있도록 하는 애플리케이션 계층 프로토콜을 의미하기도 함
- 도메인 네임이 네임 서버를 바탕으로 리졸빙 되는 과정
  - 로컬 네임 서버 - 클라이언트와 맞닿아 있는 네임 서버로, 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 - 가장 먼저 찾게 되는 네임 서버
  - 로컬 네임 서버가 FQDN에 대응하는 IP 주소를 알고 있다면 클라이언트에게 즉시 해당 IP 주소를 반환함
  - 모른다면 로컬네임 서버는 대응하는 IP 주소를 알아낼 때까지 도메인 네임의 루트 네임 서버 → TLD 네임 서버 → 도메인 - 네임을 관장하는 네임 서버 등에 거쳐서 질의함
  - DNS 캐시 - 리졸빙이에 오랜 시간이 걸리기 때문에 응답 결과를 임시로 저장했따가 추후 같은 질의에 활용함
- 자원 - 네트워크 상의 메시지를 통해 주고받는 최종 대상
- URI - 웹 상에서의 자원을 식별하기 위한 정보
- URN - 이름으로 자원을 식별하는 방식
- URL - 위치로 자원을 식별하는 방식
  - scheme - 자원에 접근하는 방법
  - authority - 호스트를 특정할 수 있는 IP 주소나 도메인 네임
  - path - 자원이 위치하고 있는 경로
  - query - 매개변수 역할을 하는 문자열
  - fragment - 자원의 일부분, 자원의 한 조각을 가리키기 위한 정보
 
**HTTP의 특징과 메시지 구조**
- HTTP의 주된 목적은 데이터의 형식에 구애받지 않고 다양한 애플리케이션 데이터의 송수신을 가능하게 하는 것
- HTTP의 특징
  - 요청 응답 기반 프로토콜
  - 미디어 독립적 프로토콜
  - 스테이트리스 프로토콜
  - 지속 연결 프로토콜
- HTTP 메시지 구조
  - 시작 라인 - 요청인지 응답인지 구분
    - 요청 라인 - 메서드
    - 상태 라인 - 상태 코드 및 이유 구문
  - 필드 라인 - HTTP 헤더가 명시됨. 헤더 이름과 헤더 값으로 구성됨
  - 메시지 본문
 
**HTTP 메서드와 상태 코드**
- HTTP 메서드
  - `GET`, `HEAD` - 자원을 조회. 웹 브라우저를 통해 여러 웹사이트의 자원을 조회하는 것
  - `POST` - 서버로 하여금 특정 작업을 처리하도록 요청하는 용도로 사용 (대부분 생성 시에)\
  - `PUT`, `PATCH` - `PUT`은 덮어쓰기, `PATCH`는 부분적 수정을 요청
  - `DELETE` - 특정 자원의 삭제를 요청
- HTTP 상태 코드
- 200번대 - 성공 상태
  - 200 - 요청 성공
  - 201 - 요청 성공, 새로운 자원 생성됨
  - 202 - 요청을 잘 받았지만 요청 작업이 끝나지 않음
  - 203 - 요청이 성공했지만 메시지 본문 데이터가 없음
- 300 번대 - 리다이렉션 상태 코드
  - 301 - 영구적 리다이렉션. 재요청 메서드가 변경될 수 있음
  - 308 - 영구적 리다이렉션. 재요청 메서드가 변경되지 않음
  - 302 - 일시적 리다이렉션. 재요청 메서드가 변경될 수 있음
  - 303 - 일시적 리다이렉션. 재요청 메서드가 GET으로 변경됨
  - 307 - 일시적 리다이렉션. 재요청 메서드가 변경되지 않음
  - 304 - 캐시. 자원이 변경되지 않음
- 400번대 - 클라이언트 에러 상태 코드
  - 400 - 요청 메시지의 내용이나 형식 자체에 문제가 있음
  - 401 - 요청한 자원에 대한 유효한 인증이 없음
  - 403 - 요청이 서버에 의해 거부됨 (접근 권한 부족)
  - 404 - 요청받은 자원을 찾을 수 없음
  - 405 - 요청한 메서드를 지원하지 않음
- 500번대 - 서버에게 잘못이 있음
  - 500 - 요청을 처리할 수 없음
  - 502 - 중간 서버의 통신 오류
 
**HTTP 주요 헤더**
- 요청 메시지에서 주로 활용되는 HTTP 헤더
  - `Host` - 요청을 보낼 호스트가 명시되는 헤더. 도메인 네임이나 IP 주소로 표현되며, 포트 번호가 포함될 수 있음
  - `User-Agent` - 요청 메시지를 보낸 클라이언트의 프로그램과 관련한 정보가 명시됨. 브라우저의 종류, 운영체제 및 - 아키텍처의 정보, 웹 브라우저에 시각적 요소를 구현하는 렌더링 엔진 종류 등이 명시됨
  - `Referer` - 클라이언트가 요청을 보낼 때 머무르던 URL이 명시됨. 이를 통해 클라이언트의 유입 경로를 파악할 수 있음
- 응답 메시지에서 주로 활용되는 HTTP 헤더
  - `Server` - 응답 메시지를 보내는 서버 호스트와 관련된 정보가 명시됨
  - `Allow` - 처리 가능한 HTTP 헤더 목록을 알리기 위해 사용
  - `Location` - 클라이언트에게 자원의 위치를 알려 주기 위해 사용
- 요청 & 응답 메시지 모두에서 활용되는 HTTP 헤더
  - `Date` - 메시지가 생성된 날짜와 시각에 관련된 정보
  - `Content-Length` - 메시지 본문의 바이트 단위 크기를 표현하기 위해 사용
  - `Content-Type`, `Content-Language`, `Content-Encoding` - 메시지 본문이 어떻게 표현되었는지와 관련된 헤더
  - `Connection` - HTTP 메시지를 송신하는 호스트가 어떠한 방식의 연결을 원하는지 명시하는 헤더

## 5 - 6. 응용 계층 - HTTP의 응용
**쿠키**
- HTTP의 스테이트리스한 특성을 보완하기 위한 대표적 수단
- 서버에서 생성되어 클라이언트 측에 저장되는 <이름, 값> 쌍 형태의 데이터
- 서버는 쿠키를 생성하여 클라이언트에 전송하고, 클라이언트는 쿠키를 저장해 두었다가 추후 같은 서버에 요청을 보낼 때 요청 메시지에 쿠키를 포함하여 전송함
 
**캐시**
- 응답받은 자원의 사본을 임시 저장하여 불필요한 대역폭 낭비와 응답 지연을 방지하는 기술
- 유효기간이 설정되어 있음 - 데이터 간의 일관성이 깨질 수 있기 때문
- 캐시 신선도 - 캐시된 사본 데이터가 서버의 원본 데이터와 얼마나 유사한지의 정도
- 캐시의 유효기간을 설정하고 만료된 자원을 재요청함으로써 캐시 신선도를 검사할 수 있고, 원본 데이터가 변경되었을 때 해당 자원을 다시 응답받음으로써 캐시 신선도를 높게 유지할 수 있음
- 항상 원본 데이터가 변경되는 건 아니기 때문에 서버에게 원본 자원이 변경된 적이 있는지를 질의함
- 엔티티 태그(Etag) - 자원의 버전을 식별하기 위한 정보
 
**콘텐츠 협상**
- 표현 - 송수신 가능한 자원의 형태. 서버와 클라이언트가 HTTP 메시지를 주고받는 것은 자원의 표현
- 콘텐츠 협상 - 같은 자원에 대해 할 수 있는 여러 표현 중 클라이언트가 가장 적합한 자원의 표현을 제공하는 기술
 
**보안: SSL/TLS와 HTTPS**
- HTTPS - HTTP에 SSL 혹은 TLS라는 프로토콜의 동작이 추가된 프로토콜
- SSL, TLS - 인증과 암호화를 수행하는 프로토콜로, TLS는 SSL를 계승한 프로토콜
- TLS 핸드셰이크 
  - 암호화 통신을 위한 키를 생성/교환할 수 있음
  - 인증서 송수신과 검증이 이루어질 수 있음
    - 인증 기관 - 인증서의 발급과 검증, 저장 등의 역할을 수행하는 공인 기관
 
## 5 - 7. 프록시와 안정적인 트래픽
**오리진 서버와 중간 서버: 포워드 프록시와 리버스 프록시**
- 오리진 서버 - 자원을 생성하고 클라이언트에게 권한이 있는 응답을 보낼 수 있는 HTTP 서버
- 클라이언트 - 중간 서버 - 오리진 서버
- 중간 서버 
  - 프록시 - 클라이언트가 선택한 메시지 전달의 대리자. 주로 캐시 저장, 클라이언트 암호화 및 접근 제한 등의 기능을 제공함
  - 게이트웨이 - 오리진서버들을 향하는 요청 메시지를 먼저 받아서 오리진 서버들에게 전달하는 문지기, 경비 역할

**고가용성: 로드밸런싱과 스케일링**
- 가용성 - 주어진 특정 기능을 실제로 수행할 수 있는 시간의 비율
  - 업타임 / (업타임 + 다운타임)
    - 업타임 - 정상적인 사용 시간
    - 다운타임 - 정상적인 사용이 불가능한 시간
  - 결함 감내 - 문제가 발생하더라도 기능할 수 있는 능력
- 로드 밸런싱 - 트래픽의 고른 분배를 위해 사용되는 기술
  - 로드 밸런서에 의해 수행됨. 다중화된 서버와 클라이언트 사이에 위치하며 클라이언트의 요청들을 각 서버에 균등하게 분배하는 역할
  - 로드 밸런싱 알고리즘 - 부하가 균등하게 분산되도록 요청을 전달할 서버를 선택하는 방법
    - 라운드 로빈 알고리즘 - 단순히 서버를 돌아가며 부하를 전달
    - 최소 연결 알고리즘 - 연결이 적은 서버부터 우선적으로 부하를 전달
- 스케일링: 스케일 업 스케일 아웃 오토스케일링
  - 스케일 업 (수직적 확장) - 기존 서버를 더 나은 사양으로 교체하는 방법
  - 스케일 아웃 (수평적 확장) - 기존 서버를 여러 개로 두는 방법
  

### 처음 알게 된 사실 & 어려웠던 부분
세그먼트라는 건...처음 보는... TLS 자체가 조금 생소한데 그냥 SSL 이랑 비슷하다고 생각하고 이해했다
 

### Quiz
> TCP와 UDP의 주요 차이점 중 어떤 것이 맞는가?

1) TCP는 비연결형 프로토콜이고, UDP는 연결형 프로토콜이다.
2) TCP는 신뢰할 수 있는 연결을 제공하며, UDP는 신뢰할 수 없는 연결을 제공한다.
3) TCP는 데이터그램을 사용하고, UDP는 바이트 스트림을 사용한다.
4) TCP는 패킷의 유실이 발생할 수 있고, UDP는 패킷의 유실이 발생하지 않는다.

> HTTP의 상태 코드 중 클라이언트 에러를 나타내는 코드는 무엇인가?

1) 200
2) 301
3) 404
4) 500

> 쿠키의 주요 목적은 무엇인가?

1) 서버의 데이터를 압축하기 위해
2) 클라이언트와 서버 간의 상태 정보를 유지하기 위해
3) 데이터 전송 속도를 높이기 위해
4) 서버의 응답 시간을 단축하기 위해

> 로드 밸런싱의 주된 목적은 무엇인가?

1) 서버의 보안을 강화하기 위해
2) 트래픽을 고르게 분배하기 위해
3) 데이터 전송 속도를 증가시키기 위해
4) 클라이언트의 요청을 캐시하기 위해
 
<details>
<summary>정답</summary>
1. (2)  /  2. (3)  /  3. (2)  /  4. (2)
</details>
