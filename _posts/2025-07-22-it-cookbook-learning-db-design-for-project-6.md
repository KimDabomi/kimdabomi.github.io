---
layout: single
title: "[IT CookBook, 프로젝트로 배우는 데이터베이스 설계] 6. 개념적 설계 심화"
categories:
  - study
sidebar:
  nav: "sidebar-category"
---

## 1. 개체 심화 요소

### 키 개체 
- 해당 업무에서 원래부터 존재하는 개체. 원래 독립적으로 존재하는 개체
- 다른 개체의 부모 개체가 되므로 가장 먼저 추출해야 함

### 메인 개체
- 키 개체 간의 업무적 관련성으로 인해 생성되는 개체
- 해당 업무에서 핵심적으로 관리되는 데이터로부터 추출됨

### 액션 개체
- 메인 개체로부터 파생되어 내용이 자주 바뀌는 개체
- 초기 분석 단계에서는 잘 드러나지 않지만 모델링을 세분화하는 단계에서 도출됨

### 약한 개체
- 독립적으로 존재하지 못하고 소유 개체가 있어야 존재할 수 있는 개체
- 고유한 식별자가 없기 때문에 자신의 구분자를 소유 개체의 식별자와 결합해서 복합 식별자를 기본키로 지정해야 함

### 코드 개체
- 정보를 간단히 표현하기 위한 기호를 나타내는 개체
- 너무 많은 코드 개체를 식별하면 개념적 스키마 모델링이 지나치게 복잡해짐

### 관계 개체
- 두 개체 간의 M:N 관계로 인해 생성되는 개체. 교차 개체
- 메인 개체가 관계 개체인 경우가 많음


## 2. 관계 심화 요소

### 병렬 관계
- 두 개체 간에 2개 이상의 관계가 존재하는 것. 다중 관계

### 직렬 관계
- 병렬 관계로 나열한 여러 관계를 하나의 상위 개념으로 통합해서 M:N 관계로 변환하여 표현한 것
- 새로운 관계가 추가되었을 때 유연하게 대처할 수 있음

### 순환 관계
- 한 개체가 다른 개체가 아닌 자기 자신과 맺는 관계
- 일대다 순환 관계 - 기관의 조직도나 관리자 정보처럼 계층구조를 모델링할 때 주로 발생
- 다대다 순환 관계 - 선수 과목이나 장비의 구성 부품 정보와 같은 네트워크 구조를 모델링할 때 주로 발생


## 3. 속성 심화 요소

### 기초 속성
- 업무로부터 도출된 일반적인 속성
- 대개 데이터 요구 분석 명세서에 포함되어 있으며, 현업에서 정보를 제공해야 속성이 유지될 수 있음

### 설계 속성
- 원래는 존재하지 않았지만 필요에 따라 설계자가 추가한 속성
- 대개 데이터 요구 분석 명세서에는 포함되어 있지 않고, 설계를 진행하면서 새로 생성되는 속성

### 유도 속성
- 다른 속성으로부터 계산 등의 가공 처리를 하여 생성된 속성. 추출 속성
- 유도 속성의 값을 결정하기 위해 사용된 속성을 저장 속성이라 하며, 저장 속성의 값이 변경되면 유도 속성도 함께 변경되어야 함
- 중복의 의미가 있으므로 일반적으로 개념적 스키마 모델링 단계에서는 식별하지 않음


## 4. 관계 행렬 활용

**관계 행렬을 작성해서 분석하는 방법**
1. 개체 타입을 가장 상위 행과 가장 좌측 열에 모두 표시
2. 개체 타입 간의 관계 유무를 셀에 표시
3. 임차적으로 조금이라도 관련성이 있으면 모두 표시
4. 상관관계가 없으면 셀에 '-'를 표시
5. 순환 관계는 대각선 셀에 표시
6. 식별된 관계에 구체적인 이름을 부여
7. 관계 이름을 부여할 때 1열의 개체 타입이 주어가 되도록 함
8. 관계 행렬의 내용을 참조해서 최종 관계를 판단


## 5. 슈퍼-서브 타입 정제

### 슈퍼-서브 타입 정제 방법
- 서브타입 개체에 독자적으로 고유한 속성이 없거나 독자적인 관계가 없는 경우, 별도의 개체로 표현하지 않고 슈퍼타입 개체의 속성으로 표현
- 서브타입으로 분할된 개체 수가 너무 많은 경우, 각각의 개체를 독립된 개체 타입으로 분리하는 것이 좋음
- 서브타입으로 분할했을 때 개념적 스키마 모델링이 너무 복잡해지면 차라리 분할하지 않는 편이 좋음
- 방법
  - 슈퍼타입 개체를 기준으로 정제하는 방법
  - 서브타입 개체를 기준으로 정제하는 방법
  - 슈퍼타입과 서브타입 개체를 기준으로 정제하는 방법

### 슈퍼타입 개체 기준 정제 방법
- 응용 프로그램에서 서브타입을 구분해서 처리하지 않는 경우
- 서브타입 개체에 속하는 데이터를 명확히 구분하기 어려운 경우
- 서브타입 개체에 포함되는 속성의 수가 매우 적은 경우

### 서브타입 개체 기준 정제 방법
- 슈퍼타입 개체에 속하는 속성의 수가 적은 경우
- 슈퍼타입 개체와 관련된 관계가 적은 경우
- 슈퍼타입 개체에 접근하는 응용 프로그램의 수가 적은 경우

### 슈퍼타입과 서브타입 개체 기준 정제 방법
- 데이터 모델의 유연성을 보장해야 하는 경우
- 서브타입 개체를 구분해서 처리하는 응용 프로그램과 구분 없이 처리하는 응용 프로그램의 수가 비슷한 경우
- 추후 다양한 응용 프로그램이 추가될 예정인 경우


## 6. 카테고리 정제

**카테고리**란 별개의 개체 타입들의 집합

### 카테고리를 정제하는 방법
- 카테고리(써브타입 개체)를 독립된 개체로 만들고, 기본키를 포함시킴
- 카테고리에 속하는 모든 개체 타입(슈퍼타입 개체)을 카테고리 개체와 각각 1:N 관계로 연결


## 7. 속성을 개체로 전환

많은 개체 인스턴스가 널 값을 갖는 속성 그룹이 있는 경우 또는 많은 속성을 특징별로 그룹핑할 수 있는 경우에는 해당 속성들을 개체로 전환할 필요가 있음
- 널 값을 갖는 속성 그룹 전환하기 - 많은 개체 인스턴스가 널 값을 갖는 속성 그룹은 별도의 개체로 분리하고, 원래 개체와 1:1 관계로 연결하는 것이 바람직
- 특징별 그룹핑이 가능한 속성 그룹 전환하기 - 속성의 수가 많으면서 특징별로 그룹핑할 수 있는 경우, 특징 그룹별로 별도의 개체로 분리할 수 있음


## 8. 개체/관계/속성 검증

### 개체 검증 방법
- 유용한 정보를 제공하는가?
- 다른 개체와 구분되는가?
- 기본키를 포함하고 있는가?
- 속성의 수가 2개 이상인가?
- 실제 데이터(개체 인스턴스)가 2개 이상 존재하는가?
- 다른 개체와 관련성이 있는가?

### 관계 검증 방법
- 관계가 현재 업무 규칙에 적합한가?
- 관계 이름이 두 개체 사이의 업무적 연관성을 구체적으로 표현하는가?
- 관계의 유형이 적절한가?
- 관계의 카디널리티가 적절한가?
- 필수/선택 여부, 즉 전체 참여와 부분 참여가 적절한가?

### 속성 검증 방법
- 각각 다른 의미를 갖는 여러 개의 속성을 묶어서 하나의 속성으로 정의하였는가?
- 모든 개체가 동일한 값을 갖고 있는가?
- 코드 값을 갖는 속성의 경우, 현업에서 통상적으로 사용되는 코드 값을 갖는가?
- 전산 처리에 필요한 플래그 형태의 속성인가?
