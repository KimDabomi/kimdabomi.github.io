어떤 기술에 대해 언제 쓰면 좋은지보다, 언제 쓰면 안되는지를 아는 것이 더 중요하다. 
우리한테 적합한지 아닌지를 판단하는 것이 중요하다.
1. 즉시 로딩과 지연 로딩 
@OneToOne 매핑 (기본값 EAGER)
단방향
FetchType.EAGER - 객체 참조의 위치와 FK의 위치가 동일하면, 예상한 대로 한번에 join 되어 조회됨
FetchType.LAZY - 객체 참조의 위치와 FK의 위치가 동일하면, 호출이 발생할 때 join 되어 조회됨
양방향
FetchType.LAZY
객체 참조의 위치와 FK의 위치가 다르면, 양쪽 모두 LAZY 인 경우
부모 쪽에서 조회할 때에는 단방향의 경우와 동일하게 동작함
자식 쪽에서 조회할 때에는 LAZY 여도 부모도 함께 조회됨 (FK를 모르기 때문에, LAZY로 세팅했지만 EAGER처럼 동작함)
기본키 공유 방식도 동일하게 동작함


2. 연관 관계 - 컬렉션 매핑
컬렉션 타입 
백(Bag) 컬렉션 - 중복 허용, 순서 유지 X, 가장 효율적인 성능 특성
private Collection<Screening> screenings = new ArrayList<>();

셋(Set) 컬렉션 - 중복 허용 X, 순서 유지 X
private Set< Screening> screenings = new HashSet<>();

리스트(List) + @OrderColumn 컬렉션 - 중복 허용, 순서 유지, 정말 필요한 경우가 아니라면 가급적 사용하지 말자
@OrderColumn(name="CONDTION_ORDER")
private List< Screening> screenings = new ArrayList<>();

맵(Map) 컬렉션 - 중복 허용 X, 순서 유지 X, 키와 값 구성 
컬렉션은 매핑 방식보다 런타임의 동작 방식이 더 중요
FK를 모르는 객체(영화)가 FK를 가지고 있는 객체(상영)의 컬렉션을 포함한다고 가정
단방향 @OneToMany
런타임에 컬렉션의 지연 로딩과 변경 감지를 담당하는 Hibernate의 컬렉션 래퍼로 대체됨
JPA 구현체가 정해진 컬렉션 인터페이스와 구현체의 조합으로 래퍼를 생성하기 때문에 선언 시에 함께 초기화 하는 것이 좋음
@OneToMany(cascade = CascadeType.PERSIST)
private Collection<Screening> screenings = new ArrayList<>();
컬렉션 요소를 삭제
관계만 끊은 것. 레코드는 그대로 두고 FK만 null로 변경됨
위 상태에서 상영만 따로 조회할 수 있는 구조라면 괜찮지만,
무조건 영화를 통해서만 상영을 조회할 수 있다면 고아 객체가 생기므로
요소 자체를 삭제해야 함 - orphanRemoval = true 설정
단방향 컬렉션 매핑은 엔티티를 추가할 때 많은 쿼리가 실행될 수 있음
쿼리 횟수를 줄이고 싶다면? 양방향 컬렉션 매핑 사용, FK를 알고 있기 때문에 따로 업데이트가 발생하지 않음
값 객체 컬렉션 매핑﻿
@ElementCollection - 값 객체임을 알려줌
@CollectionTable - 컬렉션 테이블을 만들어줌
값 객체 컬렉션에 요소를 추가할 때에는, 원래 있던 걸 다 삭제하고 추가된 요소까지 합쳐서 다시 추가됨
값 객체 컬렉션을 전체 삭제할 때에는, 단일 쿼리로 모두 삭제
참조 객체는 요소를 추가할 때에는 추가된 요소만 저장, 삭제는 요소만큼 삭제
값 객체는 요소를 추가할 때에는 전체 요소 삭제 후 전체 요소를 다시 저장, 삭제는 한 쿼리로 전체 요소 삭제
