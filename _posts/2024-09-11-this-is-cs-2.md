---
layout: single
title: "[이것이 취업을 위한 컴퓨터 과학이다] 2-3 ~ 2-5"
categories:
  - study
sidebar:
  nav: "sidebar-category"
---

## 2 - 3. CPU

**레지스터**는 CPU 안에 있는 작은 임시 저장장치. CPU 안에는 다양한 레지스터들이 있고, 각기 다른 이름과 역할이 있음
- 프로그램 카운터 - 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장
- 명령어 레지스터 - 해석할 명령어, 즉 메모리에서 방금 읽어 들인 명령어를 저장
- 범용 레지스터 - 다양하고 일반적인 상황에서 자유롭게 사용 가능
- 플래그 레지스터 - 연산의 결과 혹은 CPU 상태에 대한 부가정보인 플래그 값을 저장
  - 플래그 - CPU가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미하는 비트
    - 부호 플래그
      - 제로 플래그
    - 캐리 플래그
    - 오버플로우 플래그
    - 인터럽트 플래그
    - 슈퍼바이저 플래그
- 스택 포인터 - 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리킴
 
**인터럽트**는 CPU의 작업을 방해하는 신호
- 동기 인터럽트(예외) - CPU에 의해 발생하는 인터럽트
  - 폴트 - 예외를 처리한 직후에 예외가 발생한 명령어부터 실행을 재개
  - 트랩 - 예외를 처리한 직후에 예외가 발생한 명령의 다음 명령어부터 실행을 재개 (ex/ 디버깅)
  - 중단 - CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생
  - 소프웨어 인터럽트 - 시스템 콜이 발생했을 때 발생
- 비동기 인터럽트(알림) - 입출력장치에 의해 발생하는 인터럽트 -> 하드웨어 인터럽트
  - CPU는 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용
  - 하드웨어 인터럽트를 사용하면 CPU는 작업이 끝나기를 마냥 기다릴 필요가 없음
  - 입출력 완료 여부를 확인하기 위한 CPU 사이클 낭비를 최소화하고, CPU가 다른 일을 수행할 수 있는 시간을 벌어 줌으로써 효율적으로 명령어를 처리할 수 있도록 도움
  - 인터럽트 요청 신호 -> 인터럽트 여부 확인 -> 인터럽트 받아들일 수 있는지 확인 -> 작업 백업 -> 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 실행 -> 백업해둔 작업 재개
    - 인터럽트 요청 신호 - CPU에게 인터럽트의 가능 여부를 확인하는 것
    - 인터럽트 플래그 - 하드웨어 인터럽트를 받아들일지, 무시할지를 결정
    - 인터럽트 서비스 루틴(인터럽트 핸들러) - 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램
    - 인터럽트 벡터 - 인터럽트 서비스 루틴을 식별하기 위한 정보
 
**CPU 성능 향상을 위한 설계**
- 클럭 - 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 시간의 단위. 클럭 속도는 CPU의 속도 단위로 간주되기도 함
- 멀티코어 & 멀티스레드
  - 멀티코어 CPU(멀티코어 프로세서) - 명령어를 읽어 들이고, 해석하고, 실행하는 부품들인 코어를 여러 개 포함하고 있는 CPU
  - 멀티스레드 CPU(멀티스레드 프로세서) - 하나의 코어가 동시에 처리하는 명령어의 단위인 하드웨어 스레드가 여러 명령어를 동시에 처리하는 CPU
- 소프트웨어 스레드 - 하나의 프로그램에서 독립적으로 실행되는 단위
- 병렬성 - 작업을 물리적으로 동시에 처리하는 성질
- 동시성 - 동시에 작업을 처리하는 것처럼 보이는 성질
 
**명령어 병렬 처리 기법**은 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시킴으로써 CPU의 성능을 높이는 기법
- 명령어 파이프라이닝 - 같은 단계가 겹치지만 않는다면 CPU가 각각의 단계를 동시에 실행할 수 있음
- 명령어 인출 -> 명령어 해석 -> 명령어 실행 -> 결과 저장
- 공장의 생산 라인과 같이 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법
- 명령어 집합 유형
  - CISC
    - 다채로운 기능을 지원하는 복잡한 명령어들로 구성됨. 적은 수의 명령어로도 프로그램 실행 가능
    - 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하기 때문에, 명령어의 크기 및 실행되기까지의 시간이 일정하지 않고, 하나의 명령어 실행에 여러 클럭 주기가 필요함
    - 비교적 명령어의 수행 시간이 길고 들쑥날쑥하기 때문에 파이브라이닝에 비효율적일 수 있음
  - RISC
    - 비교적 활용 가능한 명령어의 종류가 적음. 짧고 규격화된 명령어, 되도록이면 1클럭 내외로 실행되는 명령어 지향
    - 비교적 크기가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 파이프라이닝에 최적화
- 파이프라인 위험 - 파이프라이닝이 실패하여 성능 향상이 이루어지지 않는 상황
  - 데이터 위험 - 명령어 간의 데이터 의존성에 의해 발생. 의존성이 있는 두 명령어를 무작정 겹쳐서 실행할 수 있음
  - 제어 위험 - 프로그램 카운터의 갑작스러운 변화에 의해 발생. 미리 인출하거나 해석 중인 명령어들은 쓸모가 없어짐
  - 구조적 위험(자원 위험) - 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생 

## 2 - 4. 메모리

실행 중인 프로그램은 메모리에 저장되며, CPU는 메모리에 저장된 정보를 읽고, 쓰고, 실행함<br />
RAM은 휘발성 저장장치. CPU는 보조기억장치에 저장된 프로그램을 바로 실행할 수 없기 때문에, 메모리로 복사해 와야 함<br />
RAM이 용량이 충분히 크면 보조기억장치로부터 많은 데이터를 가져와 미리 RAM에 저장할 수 있기 때문에 많은 프로그램을 동시에 실행하는 데 유리함
- RAM은 임의 접근 메모리
  - 임의 접근(직접 접근) - 저장된 요소에 순차적으로 접근할 필요 없이 임의의 위치에 곧장 접근 가능한 방식
  - 순차 접근 - 특정 위치에 저장된 요소에 접근하기 위해 처음부터 순차적으로 접근하는 방식
- DRAM
  - 시간이 지나면 저장된 데이터가 점차 사라짐
  - 일정 주기로 데이터를 재활성화해야 함
  - 소비 전력이 낮고, 저렴하며, 집적도가 높아 메모리를 대용량으로 설계하기에 용이
- SRAM
  - 시간이 지나도 저장된 데이터가 사라지지 않음
  - 전원이 공급되지 않으면 저장된 내용이 소실됨
  - 속도가 빨라야 하는 저장장치에 사용 (캐시 메모리 등)
- SDRAM
  - 클럭 신호와 동기화된, 보다 발전된 형태의 DRAM
  - 클럭에 맞춰 작동하며 CPU와 정보를 주고받을 수 있는 DRAM
- DDR SDRAM
  - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
  - 두 배의 대역폭으로 한 클럭당 두 번씩 CPU와 데이터를 주고받을 수 있음
  - 전송 속도가 두 배 빠름

**메모리에 바이트를 밀어 넣는 순서**
- 빅 엔디안 - 낮은 번지의 주소에 상위 바이트부터 저장하는 방식. 직접 읽거나, 디버깅 시에 편리
- 리틀 엔디안 - 낮은 번지의 주소에 하위 바이트부터 저장하는 방식. 수치 계산이 편리
- 16진수 1A2B3C4D를 저장하면 빅 엔디안에는 1A, 2B, 3C, 4D 순으로 / 리틀 엔디안에는 4D, 3C, 2B, 1A 순으로 저장됨
 
**캐시 메모리**는 CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생한 저장장치. CPU와 메모리 사이에 위치한 SRAM 기반의 저장장치. 캐시 메모리는 CPU가 사용할 법한 것을 저장<br />
캐시 메모리를 사용한다는 것, 캐싱한다는 것은 데이터 접근에 있어 어느 정도의 빠른 성능은 보장할 수 있지만, 그와 동시에 데이터의 일관성을 유지하기 위한 책임이 따르는 방식
- 캐시 히트 - 캐시 메모리가 예측하여 저장한 데이터가 CPU에 의해 실제로 사용되는 경우
- 캐시 미스 - 예측이 틀려서 CPU가 메모리로부터 필요한 데이터를 직접 가져와야 하는 경우
- 캐시 적중률 - 캐시가 히트되는 비율
- 참조 지역성의 원리 - 메모리로부터 가져올 데이터를 결정하는 특정한 원칙
  - 시간 지역성 - CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있음 (ex/ 변수)
  - 공간 지역성 - CPU는 접근한 메모리 공간의 근처에 접근하려는 경향이 있음 (ex/ 배열)
- 캐시 메모리의 쓰기 정책과 일관성 - CPU가 캐시 메모리에 데이터를 쓸 때는 캐시 메모리에 새롭게 쓰여진 데이터와 메모리 상의 데이터가 일관성을 유지해야 함
  - 즉시 쓰기
    - 메모리를 항상 최신 상태로 유지하여 캐시 메모리와 메모리 간의 일관성이 깨지는 상황 방지
    - 데이터를 쓸 때마다 메모리는 참조해야 하므로 버스의 사용 시간과 쓰기 시간이 늘어남
  - 지연 쓰기
    - 캐시 메모리에만 값을 써 두었다가 추후 수정된 데이터를 한 번에 메모리에 반영하는 방법
    - 메모리와 캐시 메모리 간의 일관성이 깨질 수 있는 위험

## 2 - 5. 보조기억장치와 입출력장치

보조기억장치의 본분은
- 전원이 꺼져도 데이터를 안전하게 보관하는 것
- CPU가 필요로 하는 정보를 조금이라도 빠른 성능으로 메모리에게 전달하는 것
- 하드 디스크 드라이브 - 자기적인 방식으로 데이터를 읽고 쓰는 보조기억장치
- 플래시 메모리 - 전기적인 방식으로 데이터를 읽고 쓰는 반도체 기반의 저장장치

**RAID**는데이터의 안정성, 성능을 확보하기 위해 여러 개의 독립적인 보조기억장치를 하나의 보조기억장치처럼 사용하는 기술
- 구성하는 방법 (RAID 레벨)
  - RAID0
    - 데이터를 여러 보조기억장치에 단순하게 나누어 저장하는 구성 방식
    - 줄무늬처럼 분산되어 저장된 데이터는 스트라입. 저장하는 동작은 스트라이핑
    - 빠른 입출력 속도
    - 저장된 정보다 안전하지 않음
  - RAID1
    - 완전한 복사본을 만들어 저장하는 구성 방식 (미러링)
    - 복구가 간단하고 안정성이 높음
    - 복사본이 저장된 크기만큼 사용 가능한 용량이 적어짐
  - RAID4
    - 패리티(오류를 검출할 수 있는 정보) 정보를 저장하는 디스크를 따로 두는 구성 방식
    - 패리티를 저장하는 장치에 병목 현상 발생 가능
  - RAID5
    - 패리티를 분산하여 저장하는 구성 방식
    - RAID4의 단점인 병목 현상 보완 가능
  - RAID6
    - 서로 다른 2개의 패리티를 두는 구성 방식
    - 오류를 검출하고 복구할 수 있는 수단이 2개
    - 안정성이 높음
    - RAID5에 비해 쓰기 속도는 일반적으로 느림
 
**입출력 기법**은 다양한 입출력장치들이 컴퓨터 내부와 정보를 주고받는 방식<br />
입출력장치는 CPU와 직접 연결되어 정보를 주고받지 않고, 장치 컨트롤러라는 하드웨어를 통해 연결됨
- 장치 컨트롤러 - CPU와 입출력장치 사이의 통신을 중개하는 중개자 역할의 하드웨어
- 장치 드라이버 - 장치 컨트롤러의 동작을 알고, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 프로그램
 
**프로그램 입출력**은 프로그램 속 명령어로 입출력 작업을 수행하는 방법
- 다중 인터럽트 처리
  - 인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우 -> 우선순위가 더 높은 인터럽트가 우선적으로 처리됨
  - PIC(프로그래머블 인터럽트 컨트롤러) - 여러 장치 컨트롤러에 연결되어 있어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤, CPU에게 지금 처리해야 할 하드웨어 인터럽트가 무엇인지를 알려 주는 장치
  
프로그램 기반의 입출력과 인터럽트 기반의 입출력에 공통점이 있다면 CPU가 입출력장치와 메모리 간의 데이터 이동을 주도해야 하며, 이동하는 데이터들도 반드시 CPU를 거침<br />
하지만 *DMA 입출력*은 CPU를 거치지 않고도 입출력장치와 메모리가 상호작용할 수 있는 입출력 방식
- DMA 입출력을 위해서는 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요함
- DMA 컨트롤러는 시스템 버스에 연결됨
- 입출력장치들의 장치 컨트롤러들은 입출력 버스라는 입출력장치 컨트롤러의 전용 버스와 연결됨
  - 대표적인 입출력 버스 - PCIe
    - 버전에 따라 최대 속도가 달라질 수 있음
    - 여러 레인(PCIe 버스를 통해 정보를 송수신하는 단위)을 이용해 정보를 주고받을 수 있음
- DMA 입출력 과정
  - CPU가 DMA 컨트롤러에게 입출력 작업을 명령
  - DMA 컨트롤러가 직접 장치 컨트롤러와 상호작용하며 입출력 작업 수행
  - DMA 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트를 걸어 작업 종료 알림
 
### 처음 알게 된 사실

캐시 메모리가 미리 예측을 하고 보조기억장치에서 메모리들을 빼와서 저장하는 줄 몰랐음<br />
RAID는 알았는데, 이렇게 많은 종류가 있는 줄은 몰랐음<br />
DMA 입출력...? 금시초문스... CPU를 거치지 않고 입출력이 가능하다니 BIG신기

### 어려웠던 부분

DMA 입출력 과정을 이해하는 게 좀 어려웠다. DMA 컨트롤러 하드웨어가 필요하고~ 근데 이 컨트롤러를 사용하려면 시스템 버스에 연결되어 있어야 되고~ 이 시스템 버스는 또 입출력장치 컨트롤러의 전용 버스와 연결되고~ 그 입출력 버스는 또 레인을 이용하고~ 무슨 마트료시카도아니고~ 그래서 [다른 글](https://naeunbi698.tistory.com/195)도 좀 찾아봤다

 
### 흥미로운 부분

캐시가 꽤나... 더 똑똑했구나.. 내 머리를 캐시로 쓴다는 건 어쩌면 더 어려운 일일지도...

### Quiz
> CPU의 명령어 레지스터는 어떤 정보를 저장하는 역할을 하는가?

1) 프로그램 카운터<br />
2) 해석할 명령어<br />
3) 플래그 값<br />
4) 스택 포인터

> RAM의 특징 중 어떤 것이 맞는가?

1) 비휘발성 저장장치<br />
2) 순차 접근 방식<br />
3) 휘발성 저장장치<br />
4) 데이터가 시간이 지나도 사라지지 않음

> RAID1의 구성 방식은 무엇인가?

1) 데이터를 여러 보조기억장치에 나누어 저장<br />
2) 완전한 복사본을 만들어 저장<br />
3) 패리티 정보를 저장하는 디스크를 따로 둠<br />
4) 서로 다른 2개의 패리티를 두는 방식

<details>
<summary>정답</summary>
1. (2) / 2. (3) / 3. (2)
</details>
