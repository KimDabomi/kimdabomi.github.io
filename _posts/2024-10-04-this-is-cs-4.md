---
layout: single
title: "[이것이 취업을 위한 컴퓨터 과학이다] 4-1 ~ 4-6"
categories:
  - study
sidebar:
  nav: "sidebar-category"
---

## 4 - 1. 자료구조의 큰 그림
**시간 복잡도** 
- 알고리즘의 성능 판단에 주로 사용되는 척도
- 입력의 크기에 따른 프로그램 실행 시간의 관계
- 입력의 크기에 따른 연산 횟수
- 빅 오 표기법
  - 점근적 상한을 표기하는 방법. 입력에 따른 실행 시간의 점근적 상한
  - 입력하는 n이 점점 증가해 무한대로 커진다고 하더라도 실행 시간이 대략 이 이상은 커지지 않을 것이라는 의미
  - 최고차항의 차수만 고려함
- 빅 세타 표기법 - 평균적인 실행 시간
- 빅 오메가 표기법 - 입력에 대한 실행 시간의 점근적 하한

**공간 복잡도**
- 프로그램이 실행되었을 때 필요한 메모리 자원의 양
- 입력에 따른 메모리 사용량의 척도
- 빅 오 표기법 - 입력에 따라 필요한 메모리 자원의 양에 대한 점근적 상한
 
## 4 - 2. 배열과 연결 리스트
**배열**
- 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조
- 각 요소에는 0부터 시작하는 고유한 순서 번호인 인덱스가 매겨짐
- RAM과 유사함. 어떤 주소에 접근하든 접근 시간이 일정함. O(1)
- 탐색, 추가, 삭제의 시간 복잡도는 O(N) 

**연결 리스트**
- 노드의 모음으로 구성된 자료 구조
- 노드란 저장하고자 하는 데이터 + 다음 노드의 위치(메모리 상의 주소) 정보를 포함하는 연결 리스트의 구성 단위
- 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용
- 특정 요소에 접근할 때에는 앞에서부터 순차적으로 접근해야 하기 때문에 O(N)
- 추가, 삭제의 시간 복잡도는 O(1)
- 싱글 연결 리스트
  - 한 쪽 방향으로 꼬리에 꼬리를 무는 형태
  - 특정 노드를 통해 다음 노드의 위치만 알 수 있고, 이전 노드의 위치는 알기 ㅇ어려움
  - 단방향 탐색만 가능
- 이중 연결 리스트
  - 싱글 연결 리스트 보완
  - 다음 노드 위치 정보 + 이전 노드 위치 정보 포함
  - 양방향 탐색 가능
  - 저장 공간이 더 필요함
- 환형 연결 리스트 (원형 연결 리스트)
  - 꼬리 노드가 헤드 노드를 가리켜 노드들이 원형으로 구성됨
  - 모든 노드 데이터를 여러 차례 순회해야 할 때 유용
 
## 4 - 3. 스택과 큐
**스택**
- 한 쪽에서만 데이터의 삽입 및 삭제가 가능한 자료구조
- 푸시 - 스택에 데이터를 저장하는 연산
- 팝 - 스택에서 데이터를 빼내는 연산
- 후입선출 (LIFO)
- 최근에 임시 저장한 데이터를 가장 먼저 활용해야할 때에 유용 (뒤로가기 등)

**큐**
- 기본적으로 한 쪽으로 데이터를 삽입하고, 다른 한 쪽으로 데이터를 삭제할 수 있는 자료구조
- 선입선출 (FIFO)
- 인큐 - 큐의 한 쪽 끝에 데이터를 삽입하는 연산
- 디큐 - 다른 한 쪽 끝으로 데이터를 빼내는 연산
- 임시 저장된 데이터를 차례차례 내보내거나 꺼내 와야 하는 각종 버퍼로도 활용됨
- 원형 큐 - 데이터를 삽입하는 쪽과 삭제하는 쪽, 양쪽을 하나로 연결해 원형으로 사용하는 자료구조
- 덱 (양방향 큐) - 양쪽으로 데이터를 삽입/삭제할 수 있는 큐
- 우선순위 큐 - 저장된 요소들이 선입선출이 아니라 우선순위가 높은 순으로 처리되는 큐. 힙 기반
 
## 4 - 4. 해시 테이블
- 키-값의 대응으로 이루어진 표(테이블)와 같은 형태의 자료구조
- 키는 해시 테이블에 대한 입력, 값은 키를 통해 얻고자 하는 데이터
- 버킷 - 키를 통해 얻고자 하는 데이터가 저장되어 있는 곳
  - 버킷은 여러 개가 존재하며, 여러 버킷들은 배열을 형성함
  - 해시 함수는 키를 인자로 활용해 버킷 배열의 인덱스를 반환함
- 해시 함수는 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수
  - 특정 입력 데이터를 고정된 길이의 해시 값으로 변환할 수는 있어도, 반대로 해시 값을 토대로 어떤 데이터가 입력되었는지를 도출하기는 어려움
  - 해시 알고리즘 - 해시 함수의 연산 방법
  - 무작위 값을 만들거나 단방향 암호를 만들 때, 데이터의 무결성을 검증하기 위해 사용되기도 함
  - 비밀번호 저장할 때 사용
- 빠른 검색 속도 - 검색, 삽입, 삭제 시간 복잡도 O(1)
- 상대적으로 많은 메모리 공간이 소모됨
- 해시 충돌 - 서로 다른 키에 대해 같은 해시 값이 대응되는 상황
- 해시 충돌을 해결하기 위한 방법
  - 체이닝
    - 충돌이 발생한 데이터를 연결 리스트로 추가하는 방법
    - 서로 다른 키가 같은 위치로 해시되어도 단순히 연결 리스트의 노드가 추가될 뿐이기 때문에, 하나의 테이블 인덱스에 여러 데이터가 연결 리스트의 노드로써 존재할 수 있음
  - 개방 주소법
    - 충돌이 발생한 버킷의 인덱스가 아닌 다른 인덱스에 데이터를 저장하는 방법
    - 조사 - 충돌이 발생했을 때 비어 있는 다른 버킷의 인덱스를 찾는 과정
  - 선형 조사법
    - 충돌이 발생했을 때, 충돌이 발생한 인덱스의 다음 인덱스부터 순차적으로 가용한 인덱스를 찾아 나서는 방법
    - 해시 충돌이 발생하는 인덱스 인근에 충돌이 발생한 여러 데이터가 몰려 저장될 수 있는 문제인 데이터 의 군집화가 일어날 수 있음
  - 이중 해싱
    - 2개의 해시 함수를 사용하는 방법으로, 충돌이 발생했을 때 다른 해시 함수에 대한 해시 값만큼 떨어진 거리에 위치한 인덱스를 찾는 방법
    - 해시 함수를 통해 무작위로 인덱스가 생성될 수 있다면 군집화 문제를 피할 수 있음
 
## 4 - 5. 트리
**트리**
- 주로 계층적인 구조를 표현하기 위한 자료구조 
- 노드 - 데이터가 저장됨
  - 부모 노드 - 상하 관계에서 상위에 위치한 노드
  - 자식 노드 - 상하 관계에서 하위에 위치한 노드
  - 형제 노드 - 같은 부모 노드를 공유하는 노드
  - 조상 노드 - 부모 노드와 그 부모 노드들
  - 자손 노드 - 자식 노드와 그 자식 노드들
  - 루트 노드 - 분모 노드가 없는 최상단 노드
  - 리프 노드 - 뻗어 나가는 트리의 최하단 끝의 노드
- 간선(링크) - 노드와 노드를 연결
- 차수 - 각 노드가 가지는 자식 노드의 수
- 레벨 - 루트 노드에서 시작해 특정 노드에 이르기까지 거치게 되는 간선의 수
- 높이 - 가장 높은 레벨
- 서브트리 - 트리 안에 포함되어 있는 트리
- 하나의 노드 = 데이터를 저장할 공간 + 자식 노드의 위치 정보(메모리 상의 주소)

**트리의 순회** 
- 트리의 모든 노드를 한 번씩 방문하는 것
- 전위 순회 - 루트 노드 → 왼쪽 서브트리 전위 순회 →  오른쪽 서브트리 전위 순회
- 중위 순회 - 루트 노드 기준 왼쪽 서브트리 중위 순회 →  루트 노드 방문 →  오른쪽 서브트리 중위 순회
- 후위 순회 - 루트 노드 기준 왼쪽 서브트리 후위 순회 → 오른쪽 서브트리 후위 순회 → 루트 노드 방문

**이진 트리** 
- 자식 노드의 개수가 2개 이하인 트리
- 편향된 이진 트리 - 모든 자식 노드가 한 쪽으로 치우친 이진 트리
- 정 이진 트리 - 자식 노드의 개수가 1개가 아닌 이진 트리
- 포화 이진 트리 - 리프 노드를 제외한 모든 노드들이 자식 노드를 2개씩 가지고 있고, 모든 리프 노드의 레벨이 동일한 - 이진 트리
- 완전 이진 트리 - 마지막 레벨을 제외한 모든 레벨이 2개의 자식 노드를 가지고 있으며, 마지막 레벨의 모든 노드들이 왼쪽부터 존재하는 이진 트리

**탐색에 활용되는 트리: 이진 탐색 트리와 힙**
- 이진 탐색 트리 
  - 특정 노드의 왼쪽 서브트리에는 해당 노드보다 작은 값을 지닌 노드들이 있고, 오른쪽 서브트리에는 해당 노드보다 큰 값을 지닌 노드들이 있는 구조의 이진 트리
  - O(log n)으로 원하는 값을 탐색할 수 있음
- 힙
  - 완전 이진 트리의 종류 중 하나, 최댓값과 최솟값을 빠르게 찾기 위해 사용됨
  - O(log n)의 시간 복잡도
  - 최대 힙 - 부모 노드가 자식 노드의 값보다 큰 값으로 이루어진 이진 트리. 우선순위 큐
  - 최소 힙 - 부모 노드가 자식 노드의 값보다 작은 값으로 이루어진 이진 트리

**균형을 맞추는 트리: RB 트리**
- 삽입과 삭제 연산을 반복하는 과정에서 트리가 한 쪽으로만 자라날 수 있는 문제를 해결하기 위한 이진 탐색 트리
- RB 트리 - 노드에 색을 칠하는 규칙, 노드에 칠해진 색을 기준으로 왼쪽 서브트리 높이와 오른쪽 서브트리 높이의 균형을 맞춤
  - 루트 노드는 블랙
  - 리프 노드는 블랙
  - 레드 노드의 자식 노드는 블랙
  - 루트 노드에서 임의의 리프 노드에 이르는 경로의 블랙 노드 수는 같음
- 새 노드를 삽입할 때에는 삽입할 노드를 레드로 간주하고 일반 이진 탐색 트리와 동일하게 삽입을 수행
- 노드 삽입 이후에도 RB 트리가 유지되어야 하므로 4개의 RB 트리 조건에 부합해야 함. 부합하지 않는다면 부합할 때까지 트리를 회전하거나 색상을 재지정하게 됨

**대용량 입출력을 위한 트리: B 트리**
- 다진 탐색 트리 - 한 노드가 여러 자식 노드를 가질 수 있는 트리
- 한 노드가 가질 수 있는 자식 노드의 수는 최소, 최대 개수가 정해져 있음
- 최대 자식 노드의 개수가 m개인 B 트리는 m차 B 트리라고 부름. 가질 수 있는 최소 자식 노드의 개수는 m/2 개
- 하나 이상의 키 값이 존재하고, 각 키들은 오름차순으로 저장되어 있음
- 키를 알면 키에 대응되는 데이터도 알 수 있음
- 키 사이사이에 자식 노드가 존재하기 때문에, 키가 n개인 노드가 가질 수 있는 자식 노드의 수는 n + 1 개
- 모든 리프 노드의 깊이가 같음
- 파일 시스템, 데이터베이스와 같이 대량의 데이터를 기반으로 탐색, 접근, 저장을 수행할 때 활용
 
## 4 - 6. 그래프
**그래프**
- 정점이라 불리는 데이터를 간선 혹은 링크로 연결한 형태의 자료구조
- 데이터 간의 연결 관계를 표현하는 자료구조
- 연결 그래프 - 그래프 상에 있는 임의의 두 정점 사이의 경로가 존재하는 그래프
- 비연결 그래프 - 경로가 존재하지 않는 정점이 존재하는 그래프
- 방향 그래프 - 간선에 방향이 있는 그래프
- 무방향 그래프 - 방향이 없는 그래프
- 가중치 그래프 - 간선에 가중치가 부여된 그래프
  - 비용 - 간선에 부여된 값인 가중치. 역과 역 사이의 거리를 가중치로 부여할 수 있음. 음수도 가능
- 서브 그래프 (부분 그래프) - 특정 그래프의 정점과 간선의 일부분으로 이루어진 그래프
**인접 행렬 기반 그래프 표현**
- N x N크기의 행렬로 그래프를 표현하는 방법
- 연결되었을 때는 1, 아닐 때는 0
**인접 리스트 기반 그래프 표현**
- 그래프의 특정 정점과 연결된 정점들을 연결 리스트로 표현하는 방법
- 각각의 정점마다 연결 리스트를 가지는데, 특정 정점에서 나가는 간선에 연결된 정점들을 연결 리스트의 노드로 삼는다는 의미
**깊이 우선 탐색**
- 그래프에서 더 이상 방문 가능한 정점이 없을 때까지 최대한 깊이 탐색하기를 반복하는 탐색 방법
- 구현 시 유용하게 사용되는 자료구조
  - 배열 - 미방문 정점을 파악하기 위해 방문한 적이 있는 정점들을 배열로 관리
  - 스택 - 방문 중 뒤로가기가 필요할 때 사용
**너비 우선 탐색**
- 인접한 모든 정점들을 방문하고, 방문한 정점들과 연결된 모든 정점들을 방문하고, 또 방문한 정점들과 연결된 모든 - 정점들을 방문하기를 반복하는 탐색 방법
- 구현 시 유용하게 사용되는 자료구조
  - 배열 - 특정 정점과 인접한 모든 정점을 줄 세우듯 저장
  - 큐 - 어떤 정점에서 너비 우선 탐색을 할지 알기 위해 사용
**최단 경로 알고리즘**
- 한 정점에서 목적지 정점까지 이르는 가중치의 합이 최소가 되는 경로를 결정하는 알고리즘
- 지도 서비스에서 원하는 목적지까지 이르는 최단 거리를 알려주는 원리로 사용
- 다익스트라 알고리즘
  - 간선의 가중치가 음이 아닌 수라는 가정 하에 사용 가능한 알고리즘
  - 특정 정점에서 다른 모든 정점까지의 최단 거리를 구해 주는 알고리즘
 
### 처음 알게 된 사실  & 어려웠던 부분
B 트리는 처음 알았다! 여러 노드가 여러 자식 노드를 가질 수 있어서 대량 시스템에 유용함!<br />
간선의 가중치가 음수가 되는 것만 알고 다익스트라는 음수가 아닌 경우만 사용가능한 걸 처음 알았다 핳핳
 

### Quiz
> 빅 오 표기법은 무엇을 나타내는가?

1) 알고리즘의 평균 실행 시간
2) 알고리즘의 최악 실행 시간의 점근적 상한
3) 알고리즘의 최선 실행 시간의 점근적 하한
4) 알고리즘의 메모리 사용량

> 배열의 탐색 시간 복잡도는 무엇인가?

1) O(1)
2) O(N)
3) O(log N)
4) O(N^2)

> 스택을 활용하기 좋은 기능은 무엇인가?

> 해시 충돌을 해결하기 위한 방법 중 하나인 체이닝은 어떤 방식인가?

1) 충돌이 발생한 데이터를 다른 인덱스에 저장하는 방법
2) 충돌이 발생한 데이터를 연결 리스트로 추가하는 방법
3) 해시 함수를 두 개 사용하는 방법
4) 해시 값을 무작위로 생성하는 방법

> 이진 탐색 트리에서 특정 노드의 왼쪽 서브트리에는 어떤 값들이 위치해야 하는가?

1) 해당 노드보다 큰 값들
2) 해당 노드와 같은 값들
3) 해당 노드보다 작은 값들
4) 무작위 값들

> 깊이 우선 탐색(DFS)에서 주로 사용하는 자료구조는 무엇인가?

1) 배열
2) 큐
3) 스택
4) 링크드 리스트

<details>
<summary>정답</summary>
1. (2)  /  2. (1)  /  3. 뒤로 가기  /  4. (2)  /  5. (3)  /  6. (3)
</details>
