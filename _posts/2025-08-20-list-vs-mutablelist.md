---
layout: single
title: "List vs MutableList"
categories:
  - personal
sidebar:
  nav: "sidebar-category"
---

좋습니다. 🙂
Kotlin에서 `List`와 `MutableList`는 가장 자주 쓰이는 컬렉션 타입인데, 성격이 뚜렷하게 달라요. 예시와 함께 장단점을 정리해드릴게요.

---

```kotlin
fun main() {
    // 불변 List (읽기 전용)
    val list: List<String> = listOf("A", "B", "C")
    println(list[0])       // ✅ 읽기 가능
    // list.add("D")       // ❌ 컴파일 에러 (쓰기 불가)

    // 가변 MutableList
    val mutableList: MutableList<String> = mutableListOf("A", "B", "C")
    println(mutableList[0]) // ✅ 읽기 가능
    mutableList.add("D")    // ✅ 쓰기 가능
    println(mutableList)    // [A, B, C, D]
}
```


|          | List (불변)                     | MutableList (가변)                 |
| ---------- | ----------------------------- | -------------------------------- |
| **특징**     | 읽기 전용, 수정 불가                  | 요소 추가/삭제/수정 가능                   |
| **안정성**    | 값이 바뀌지 않으므로 상태 추적이 단순         | 값이 언제든 바뀔 수 있어 추적 필요             |
| **동시성**    | 여러 스레드에서 동시에 읽어도 안전           | 동시 접근 시 주의 필요 (락, 동기화 필요)        |
| **코드 가독성** | "이 값은 변하지 않는다"라는 보장이 있어 이해 쉽다 | "어디서 값이 바뀔지 모른다" → 읽는 사람이 추적해야 함 |
| **유연성**    | 컬렉션 자체를 새로 만들어야 변경 가능         | 기존 컬렉션을 바로 수정 가능, 편리함            |
| **사용 시점**  | API 응답, 설정 값, 불변 데이터          | 캐시, 임시 버퍼, 점진적 수집 로직             |

---

**`List`**: 안전, 가독성 ↑, 동시성 ↑ → \*\*“읽기 전용 데이터”\*\*에 적합<br />
**`MutableList`**: 유연, 직관적 수정 가능 → \*\*“중간 처리, 점진적 수집”\*\*에 적합

---

### 불변 객체로 변경했을 때의 이점
- 가독성 UP! 로직을 읽을 때 '여기서 무엇이 추가/삭제 되었나?'가 아닌 '이 단계는 무엇을 생성하나?'만 보면 됨
- 정확성/안정성 UP! 누군가 `add`, `remove`로 망가뜨릴 여지가 줄어듦
- 동시성/리뷰 내구성 UP! 멀티스레드 환경에서 불변일 때 더 버그가 생길 확률이 적어지고, 리뷰어 입장에서도 로직을 이해하기 쉬워짐
- 테스트 용이성 UP! 유지보수 UP! 
