---
layout: single
title: "[Day 2] JPA의 사실과 오해 4기"
---

> 어떤 기술에 대해 언제 쓰면 좋은지보다, 언제 쓰면 안되는지를 아는 것이 더 중요하다. <br />
> 우리한테 적합한지 아닌지를 판단하는 것이 중요하다. <br />

## 1. 즉시 로딩과 지연 로딩 
### @OneToOne 매핑 (기본값 EAGER)
- 단방향
  - `FetchType.EAGER` - 객체 참조의 위치와 FK의 위치가 동일하면, 예상한 대로 한번에 join 되어 조회됨
  - `FetchType.LAZY` - 객체 참조의 위치와 FK의 위치가 동일하면, 호출이 발생할 때 join 되어 조회됨
- 양방향
  - `FetchType.LAZY`
    - 객체 참조의 위치와 FK의 위치가 다르면, 양쪽 모두 LAZY 인 경우
    - 부모 쪽에서 조회할 때에는 단방향의 경우와 동일하게 동작함
    - 자식 쪽에서 조회할 때에는 LAZY 여도 부모도 함께 조회됨 (FK를 모르기 때문에, LAZY로 세팅했지만 EAGER처럼 동작함)
    - 기본키 공유 방식도 동일하게 동작함

## 2. 연관 관계 - 컬렉션 매핑
### 컬렉션 타입 
- 백(Bag) 컬렉션 - 중복 허용, 순서 유지 X, 가장 효율적인 성능 특성
  ``` java
  private Collection<Screening> screenings = new ArrayList<>();
  ```
- 셋(Set) 컬렉션 - 중복 허용 X, 순서 유지 X
  ``` java
  private Set< Screening> screenings = new HashSet<>();
  ```
- 리스트(List) + @OrderColumn 컬렉션 - 중복 허용, 순서 유지, **정말 필요한 경우가 아니라면 가급적 사용하지 말자**
  ``` java
  @OrderColumn(name="CONDTION_ORDER")
  private List< Screening> screenings = new ArrayList<>();
  ```
- 맵(Map) 컬렉션 - 중복 허용 X, 순서 유지 X, 키와 값 구성 
- 컬렉션은 매핑 방식보다 런타임의 동작 방식이 더 중요
### FK를 모르는 객체(영화)가 FK를 가지고 있는 객체(상영)의 컬렉션을 포함한다고 가정
- 단방향 `@OneToMany`
  - 런타임에 컬렉션의 지연 로딩과 변경 감지를 담당하는 Hibernate의 컬렉션 래퍼로 대체됨
  - JPA 구현체가 정해진 컬렉션 인터페이스와 구현체의 조합으로 래퍼를 생성하기 때문에 선언 시에 함께 초기화 하는 것이 좋음
  ``` java
  @OneToMany(cascade = CascadeType.PERSIST)
  private Collection<Screening> screenings = new ArrayList<>();
  ```
  - 컬렉션 요소를 삭제
    - 관계만 끊은 것. 레코드는 그대로 두고 FK만 null로 변경됨
    - 위 상태에서 상영만 따로 조회할 수 있는 구조라면 괜찮지만, <br />
      무조건 영화를 통해서만 상영을 조회할 수 있다면 고아 객체가 생기므로 <br />
      요소 자체를 삭제해야 함 - `orphanRemoval = true` 설정
  - 단방향 컬렉션 매핑은 엔티티를 추가할 때 많은 쿼리가 실행될 수 있음
  - 쿼리 횟수를 줄이고 싶다면? 양방향 컬렉션 매핑 사용, FK를 알고 있기 때문에 따로 업데이트가 발생하지 않음
### 값 객체 컬렉션 매핑﻿
- `@ElementCollection` - 값 객체임을 알려줌
- `@CollectionTable` - 컬렉션 테이블을 만들어줌
- 값 객체 컬렉션
  - 요소를 추가할 때에는, 원래 있던 걸 다 삭제하고 추가된 요소까지 합쳐서 다시 추가됨
  - 요소를 전체 삭제할 때에는, 단일 쿼리로 모두 삭제
- 참조 객체
  - 요소를 추가할 때에는 추가된 요소만 저장
  - 삭제는 요소만큼 삭제

## 3. 상속 매핑
- 클래스 상속 계층을 테이블에 매핑
- 상속의 용도
  - 다형적인 연관관계
  - JPA는 적절한 `SequenceCondition`, `PeriodCondition` 인스턴스 조회
  - 구체적인 클래스가 아닌 추상 클래스에만 의존 - `DiscountPolicy`는 추상클래스 `DiscountCondition`에만 의존
### 의존성 주입
- 구체적인 타입을 내부에서 직접 생성하지 않고 외부에서 생성해서 주입
- 단일 테이블 전략
  - 클래스 매핑 - `DiscriminatorValue`에 따라 불러옴
  - 다형적 쿼리 - `DiscountCondition` 타입에 따라 불러옴
  - 서브클래스 별 쿼리
  - 성능이 중요하고 상속 계층 리팩터링이 자주 발생할 경우 사용
  - 장점 - 빠른 조회 성능, 단순한 조회 쿼리
  - 단점 - nullable 제약 조건 강제 불가능, 테이블 크기가 커지면 성능이 느려질 수도 있음
- 조인 전략
  - 클래스 매핑 - `@Inheritance(strategy = InheritanceType.JOINED)`
  - 다형적 쿼리
  - 서브클래스 별 쿼리
  - 데이터 무결성이 중요하고 상속 계층이 안정적일 때 적용
  - 장점 - not null 제약조건 강제 가능, 테이블 정규화
  - 단점 - 상속 계층이 복잡한 경우 조인으로 인한 성능 저하 발생, 조회 쿼리 복잡
- 구현 클래스마다 테이블 전략
  - 클래스 매핑, 다형적 쿼리, 서브클래스 별 쿼리
  - 가급적 다른 전략 사용할 것
  - 장점 - 서브 타입을 구분해서 처리할 때 효과적, not null 제약조건 사용 가능
  - 단점 - 여러 자식 테이블을 함께 조회할 때 성능 저하, 자식 테이블을 통합해서 쿼리하기 어려움
- 상속 전략 혼합
  - 클래스 매핑, 다형적 쿼리, 서브클래스 별 쿼리
  - 상속 계층은 가급적 간단하게 유지
  - 클래스 레벨에서의 상속 계층 설계가 매핑 전략보다 더 중요
- **코드 재사용 때문에 상속을 사용하는 건 좋은 방법이 아님**
- 코드 재사용을 위한 더 좋은 방법
  - **상속보다 합성을 사용**
  - 올바른 상속의 용도 - 다형적인 연관관계
  - 올바른 상속 계층 - 특정 클래스 안에서 메서드를 구현하는 메서드는 단 하나만 존재
  - 꼭 데이터 상속을 해야 한다면 `@MappedSuperclass` 사용

## 4. 애그리게이트와 연관관계
