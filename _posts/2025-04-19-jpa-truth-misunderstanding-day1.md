---
layout: single
title: "[Day 1] JPA의 사실과 오해 4기"
categories:
  - education
---
> 빨리 만드는 것보다 유지보수성이 더 중요하다. <br />
> JPA는 설계를 해결해주는 것이 아니다. <br />
> 설계를 하고 설계에 맞춰서 사용해야 한다. <br />
> 모든 걸 다 객체지향으로 하라는 것이 아니라, 프로그램의 설계에 따라서 유동적으로 사용해야 한다.

## 1. ORM과 아키텍처
### 트랜잭션 스크립트
- 프로세스와 데이터 분리
- 도메인 로직을 절차적인 방식으로 구현
- 빈약한 도메인 모델
- 도메인 모델의 데이터를 이용해서 로직 처리
- 코드를 읽고 작성하기가 더 쉽지만, 유지보수성이 낮음
- 응집도 낮음. 결합도 높음
- 테이블 데이터 게이트웨이
  - 하나의 데이터베이스 테이블에 대한 게이트웨이 역할을 수행
  - 단일 테이블 또는 뷰에 접속하는 SQL 처리
- 데이터 접속 객체
  - 하나의 테이블 또는 뷰에 대한 영속성 로직을 담당하는 객체
  - 테이블 데이터 게이트웨이 패턴의 또 다른 이름

### 도메인 모델
- 프로세스와 데이터 통합
- 도메인 로직을 객체지향 방식으로 구현
- 상태와 행위를 포함하는 객체 사이의 협력을 통해 기능 구현
- 코드 읽고 작성하기가 더 어렵지만, 유지보수성이 높음
- 객체 관계 임피던스 불일치
  - 객체 모델과 DB 스키마 사이의 불일치
  - 객체 패러다임과 관계 패러다임 간의 불일치
- 데이터 매퍼 - 객체 모델과 DB 스키마 간의 독립성 유지
- 객체 관계 매핑 Object-Relational Mapping, ORM
  - 객체와 데이터베이스 테이블 사이의 매핑 기법 또는 매핑 도구
  - 일반적으로 재사용 가능한 데이터 매퍼 프레임워크를 사용
  - JPA - Java에서 사용되는 ORM
- 리파지토리 Repository
  - 데이터 매퍼 용도로 사용되는 객체
  - 일반적으로 데이터 접근 객체의 개념을 포함

### 서비스 레이어
- 도메인 로직의 재사용성 촉진
- 관심사 분리
  - 도메인 레이어 - 객체로만 사용하는 것
  - 서비스 레이어 - 기술적인 로직 
- 트랜잭션 스크립트 - 별도의 서비스 레이어가 불필요. 서비스 레이어 + 도메인 레이어
- 도메인 모델 - 서비스 레이어 / 도메인 레이어 분리

### JPA 사용 방법
- 트랜잭션 스크립트 - 비슷한 형태의 객체와 테이블 변환, SQL 자동화
- 도메인 모델 - 임피던스 불일치 해결
- 객체지향이니까 JPA를 무조건 쓴다! 가 아니라, 설계에 맞춰서 적절하게 쓰는 것이 중요
 
## 2. 기본 매핑
- `@Entity`, `@Table`, `@NoArgsConstructor`, `@Id`, `@Column`, `@Enumerated` 
- 영속성 컨텍스트 - 데이터베이스에서 조회했거나 저장할 객체들을 보관하는 곳. 식별자 맵에 모아뒀다가 작업 단위로 한번에 처리
- 식별자 맵 - 식별자 키를 기준으로 영속성 컨텍스트에서 관리되는 엔티티들을 보관
- 식별자 필드 - 식별자는 @Id로 지정된 식별자 필드에 저장
- 식별자 선택 시 고려사항
  - 자연키 / 대리키
    - 자연키 - 비즈니스 의미를 가지는 식별자 
    - 대리키 - 비즈니스 의미가 없는 식별자
    - 식별자는 변경되지 말아야 하기 때문에 대리키 선호
  - 단순키 / 복합키
    - 단순키 - 하나의 컬럼으로 식별자 구성
    - 복합키 - 여러 컬럼을 조합해서 식별자 구성
    - 일관성과 불변성 측면에서 하나의 컬럼을 사용하느 단순키 선호
  - 생성키 / 할당키
    - 생성키 - 엔티티 저장 시 JPA 또는 DB가 생성하는 키
      - `AUTO` - 데이터베이스에 적합한 최선의 전략을 선택 `GeneratedValue`의 기본값
      - `IDENTITY`
        - 기본키 생성을 데이터베이스에 위임, 데이터가 INSERT 되는 시점에 순차적인 숫자값 생성 
        - 데이터가 생성되어야 기본키가 생기기 때문에, 영속성 컨텍스트에 상관없이 생성이 먼저 됨
      - `SEQUENCE` - 데이터베이스 시퀀스를 이용해서 기본 키를 생성
      - `TABLE` - 키 생성을 위한 테이블을 이용해서 데이터베이스 시퀀스 시물레이션
    - 할당키 - 사용자가 직접 키를 객체에 할당 (GUID, 자연키)
    - 단순성과 관리 관점에서 생성키 선호
 
## 3. 참조 객체와 값 객체
### 참조 객체
- 모든 클라이언트는 동일한 객체 참조
- 하나의 참조에 의한 상태 변경이 다른 참조에도 전파
- 객체 식별자를 기반으로 동등성 체크 ( == )
  - 별칭 - 하나의 객체를 가리키는 여럴 개의 참조 변수
  - 동등성 확인 - 참조 대상 객체의 식별자를 사용해서 확인
- 협력하는 객체들 사이에 상태 변경을 공유하고 생명주기를 함께 관리
- 일반적으로 가변 객체로 구현
- 참조 객체의 별칭은 양날의 검 - 동일한 상태를 공유할 수 있지만, 원하지 않는 부수효과 발생 가능

### 값 객체
- 값이 동일하면 동일한 객체로 취급
- 불변 객체로 구현
- 객체를 추적할 필요 없이 값만 같으면 동일한 객체
- equals(hashCode) 메서드 오버라이딩
- 상태 변경이 필요하면 새로운 객체 생성 후 반환
- 개념을 명시적으로 드러내서 복잡성을 낮춰줌
- 참조 객체에서 복잡하거나 중복되는 코드 그룹을 값 객체로 이동
- 참조 객체 - 식별자를 기반으로 객체 동일성 체크, 가변 객체로 구현, 별칭 문제 발생
- 값 객체 - 속성을 기반으로 객체 동등성 체크, 불변 객체로 구현, 별칭 문제 방지

### 합성
- 값 객체를 갖고 있는 참조 객체의 생명주기에 종속됨. 참조 객체가 제거되면 값 객체도 제거됨
 

## 4. JPA의 두 가지 관점
### 구조 관점
- 주키와 식별자 필드 매핑
- 객체 참조와 외래키 매핑
- 컬렉션 매핑 - 객체와 테이블 사이의 구조 반전 - 객체의 참조 방향과 디비의 포함 관계는 반대
- 포함 값 매핑 - 테이블의 컬럼으로 저장
- 상속 매핑 - 단일 테이블 전략, 조인 전략, 구현 클래스마다 테이블 전략
- 동일한 스키마와 클래스 구조를 매핑할 수 있는 다양한 방법
  - 단방향 참조와 양방향 참조를 위한 애너테이션의 사용법 학습
  - 디비의 참조는 양방향, 객체의 참조 방향은 단방향/양방향 둘 다 가능

### 동작 관점
- 작업 단위 - 비즈니스 트랜잭션의 영향을 받는 엔티티 목록을 유지 관리하고 변경 사항 기록 및 동시성 문제 해결 조정
- 식별자 맵 - 로드된 모든 객체를 맵에 유지하여 각 객체가 한 번만 로드되도록 처리. 객체를 참조할 때 맵을 사용하여 객체 조회
- 영속성 컨텍스트 = 작업 단위 + 식별자 맵. 디비에 추가하려면 무조건 영속성 컨텐스트에 등록해야 함
- 영속 상태라는 것은 식별자 맵에 들어가 있는 상태
- 새로 생성된 객체는 비영속 상태 -> 영속성 컨텍스트에 등록해야 함
- 트랜잭션이 커밋될 때 자동으로 플러시(디비에 변동사항 반영) 처리
- 트랜잭션을 지원하는 쓰기 지연 - persist 실행 시점에 쿼리를 전송하지 않고 트랜잭션을 커밋할 때 모아둔 쿼리를 한번에 DB에 보내는 방식
- 커밋 전에 조회를 다시하면 식별자 맵에서 조회됨
- IDENTITY일 때에는 persist 상태에 INSERT가 되지만, 로그만 쌓일 뿐이지 실제로 디비에 반영된 게 아님
- 보장된 객체 식별자 범위 제공
  - 1차 캐시 역할
  - 플러시를 해도 식별자 맵에 객체가 남아있기 때문에, 재조회를 해도 쿼리가 날아가지 않고 식별자 맵에서 가져옴
- 제거 상태 - 영속성 컨텐스트에서 제거되고, 커밋될 때 DELETE 쿼리가 실행됨
- 자동 변경 감지 - 원본과 스냅샷을 비교하여 자동으로 업데이트 사항 쿼리를 등록해주고, 플러시 때 반영됨
- 준영속 상태 - 영속성 컨텍스트 비우기, 부분 지우기, 재등록하기 (거의 안쓰임. 안쓰는 것이 좋음)
- 도달 가능성에 의한 영속성 - 참조되고 있는 객체들까지 함께 영속상태로 등록할 수 있음. 설정에 따라서 여러 객체들 한번에 처리 가능
- 즉시 로딩 Eager - 참조된 객체까지 한번에 조회
- 지연 로딩 Lazy - 필요할 때 참조된 객체까지 조회. 영속성 컨텍스트가 닫히면 접근 불가
 
## 5. 쿼리 언어
- 객체를 변경한 후에 영속성 컨텍스트에 존재할 때, JPQL로 객체를 조회하면 플러시를 한 후에 조회함
 
## 6. 객체지향 설계
### 책임 주도 설계 살펴보기
동작하는 코드를 기반으로 리팩터링을 하면서 아래의 원칙을 따르도록 노력하기
나중에 코드의 위치를 찾기 쉽고, 수정 시에 사이드 이펙트가 덜 생기게 할 수 있음 -> **유지보수성 Up!**
- 데이터는 고려하지 않음
- 애플리케이션이 제공할 기능 파악
- 애플리케이션의 기능 요구사항을 시스템의 책임으로 변환
- 시스템의 책임을 객체의 책임으로 변환
- 책임을 담당할 적절한 객체 선택 - 행동의 주체를 정함으로써 나중에 행동을 찾기 쉬워짐 (TDD의 기본 원리)
- 객체의 책임 일부를 수행하기 위해 외부의 도움이 필요하다면 다른 객체에게 도움을 요청
- 이 요청을 또 다른 객체의 책임으로 변환
- 책임을 담당할 적절한 객체 선택

### CRC 카드
책임과 협력을 표현하기 위한 객체지향 설계 도구 ( Candidate - Responsibility - Collaborator )
- 책임 할당의 기본 원칙 - 도메인 개념 중에 적절한 정보 전문가에게 할당
  - [예매 생성 책임 할당] 상영 - 상영 정보를 알고있음(--영화와 협력), 상영을 예매함
  - [가격 계산 책임 할당] 영화 - 영화 정보를 알고 있음(--할인 정책과 협력), 가격을 계산함
  - [할인 금액 계산 책임 할당] 할인 정책 - 할인 계산식을 알고 있음, 할인을 계산함
  - [할인 여부를 판단할 책임 할당] 할인 조건 - 할인 조건을 알고 있음, 할인 여부를 판단함
``` java
여기 예제에서 할인 정책은 abstract protected 된 메서드를 상속받고,
할인 조건은 public interfact를 구현하는 차이가 궁금해서 GPT한테 물어본 답변
-- 둘 다 추상 메서드를 구현하는 건 같지만,
interface 는 "구현(implements)" 관계고,
추상 클래스는 "상속(extends)" 관계라서 의미 차이 존재함.
interface 는 외부 공개 규약이고,
abstract class 는 내부 상속 구조 잡는 용도로 씀.
요약하면, interface 는 공개된 규칙을 구현하는 거고,
abstract protected 는 상속받은 클래스끼리만 공유하는 기능을 완성하는 것
```

## 7. 연관관계 설정
### 연관관계
- 하나의 객체에서 다른 객체로 탐색할 수 있는 경로
- 구조 관점
  - 외래키 매핑
    - 테이블 외래키를 객체의 참조로 매핑
    - `@JoinColumn` - 객체 참조를 매핑하기 위해 사용할 FK 지정
    - 테이블 조회 - 테이블 외래키를 이용해서 두 객체 연결
    - 하나의 외래키, 두 가지 방향 - FK가 존재하는 객체에서 연관 객체를 참조하면 문제없음. 반대는 문제가 자주 발생
  - 다중성과 방향 
    - 일대일 `OneToOne`, 일대다 `OneToMany`, 다대일 `ManyToOne`, 다대다 `ManyToMany`
    - `OneToMany`, `ManyToOne`
      - 단방향 ( 상영 Many To One 영화 )
        - 디비에 FK가 있는 테이블의 객체(상영)에 Many, `@JoinColumn`
        - 반대의 경우 - FK가 없는 객체(영화)에 `@JoinColumn` 을 설정한 경우에는 문제가 자주 발생함
      - 양방향 - 복잡도 Up! 가급적 피하는 것이 좋음
        - 두 객체에 모두 `@ManyToOne`, `@OneToMany(mappedBy = "movie")` 설정
        - 두 객체 참조 싱크 맞춰줘야 함 - 새로운 걸 만들면, 기존 걸 끊고, 새로운 것과의 연결도 또 해줘야 함
        - 두 객체 중에 FK 매핑을 담당할 객체를 선택해야 함 - FK가 있는 테이블의 객체
        - FK가 있는 테이블의 객체가 참조하고 있는 객체에는 `mappedBy`를 지정해줘야 함
          - `mappedBy` - JPA에게 두 객체 참조의 싱크를 맞추도록 알려주는 용도
      - 연관관계 주인을 저장할 때 주의사항 - 연관관계 주인 쪽에 참조가 설정되지 않으면 테이블에 외래키가 저장되지 않음
      - 두 객체들이 서로 다른 객체를 참조 가능할 때는 양방향이 아님 - `@JoinTable` 애너테이션으로 매핑
    - `OneToOne`
      - 단방향
        - FK가 있는 테이블의 객체에 `@OneToOne` 매핑 선언
        - FK가 없는 테이블의 객체에서는 불가 - 꼭 필요하다면 양방향으로 해야 함
      - 양방향
        - FK가 있는 테이블의 객체에 `@OneToOne`, `@JoinColumn(name = "MOVIE_ID")`
        - FK가 없는 테이블의 객체에 `@OneToOne(mappedBy = "movie")`
        - 기본키 공유 방식
          - FK가 있는 테이블의 객체에 `@MapsId`, `@OneToOne`, `@PrimaryKeyJoinColumn(name = "MOVIE_ID")`
          - FK가 없는 테이블의 객체에 아무것도 하지 않음
- 동작 관점
  - 영속성 전이
    - 객체를 저장/삭제/수정할 때 연관관계로 연결된 객체도 함께 저장/수정/삭제됨
    - 연관된 객체들을 하나의 작업 단위로 다룰 수 있음
    - 캡슐화 - 영속성 전이가 퍼지는 단위를 정하는 것, 변화가 생겼을 때 미치는 범위를 정하는 것
    - 캡슐화는 디비 단위보다 클래스 단위로 생각하는 게 더 좋음
    - 옵션 (기본값 없음 - 설정이 없으면 아무일도 일어나지 않음)
      - `CascadeType.PERSIST` - 영속성 컨텍스트에 등록됨
      - `GenerationType.REMOVE` - 삭제됨
      - `GenerationType.DETACH` - 준영속 상태가 됨
      - `GenerationType.MERGE` - 머지됨
      - `GenerationType.REFRESH` - 새로고침됨
      - `GenerationType.ALL` - 모든 옵션이 적용됨

      ``` sql
      -- FK를 들고 있는 곳(상영)에서 객체 참조를 하고 있다면, 상영이 저장될 때 영화도 함께 저장되고 FK도 함께 저장됨
      insert into movie(fee, running_time, title, id) values (10000, 120, '한산', default)
      insert into screening(movie_id, screening_time, sequence, id) values(1, '2024-12-09T09:00', 1, default)
      
      -- 만약에 FK를 들고 있지 않은 곳에서 객체 참조를 하고 있다면, 영화와 상영을 각각 저장하고 FK를 나중에 업데이트 함
      insert into movie(fee, running_time, title, id) values (10000, 120, '한산', default)
      insert into screening(screening_time, sequence, id) values(1, '2024-12-09T09:00', 1, default)
      update screening set movie_id=1 where id=1;
      ```
