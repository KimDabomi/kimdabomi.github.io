---
layout: single
title: "[Day 2] JPA의 사실과 오해 4기"
categories:
  - education
sidebar:
  nav: "sidebar-category"
---

> 어떤 기술에 대해 언제 쓰면 좋은지보다, 언제 쓰면 안되는지를 아는 것이 더 중요하다. <br />
> 우리한테 적합한지 아닌지를 판단하는 것이 중요하다. <br />

## 1. 즉시 로딩과 지연 로딩 
### @OneToOne 매핑 (기본값 EAGER)
- 단방향
  - `FetchType.EAGER` - 객체 참조의 위치와 FK의 위치가 동일하면, 예상한 대로 한번에 join 되어 조회됨
  - `FetchType.LAZY` - 객체 참조의 위치와 FK의 위치가 동일하면, 호출이 발생할 때 join 되어 조회됨
- 양방향
  - `FetchType.LAZY`
    - 객체 참조의 위치와 FK의 위치가 다르면, 양쪽 모두 LAZY 인 경우
    - 부모 쪽에서 조회할 때에는 단방향의 경우와 동일하게 동작함
    - 자식 쪽에서 조회할 때에는 LAZY 여도 부모도 함께 조회됨 (FK를 모르기 때문에, LAZY로 세팅했지만 EAGER처럼 동작함)
    - 기본키 공유 방식도 동일하게 동작함

## 2. 연관 관계 - 컬렉션 매핑
### 컬렉션 타입 
- 백(Bag) 컬렉션 - 중복 허용, 순서 유지 X, 가장 효율적인 성능 특성
  ``` java
  private Collection<Screening> screenings = new ArrayList<>();
  ```
- 셋(Set) 컬렉션 - 중복 허용 X, 순서 유지 X
  ``` java
  private Set< Screening> screenings = new HashSet<>();
  ```
- 리스트(List) + @OrderColumn 컬렉션 - 중복 허용, 순서 유지, **정말 필요한 경우가 아니라면 가급적 사용하지 말자**
  ``` java
  @OrderColumn(name="CONDTION_ORDER")
  private List< Screening> screenings = new ArrayList<>();
  ```
- 맵(Map) 컬렉션 - 중복 허용 X, 순서 유지 X, 키와 값 구성 
- 컬렉션은 매핑 방식보다 런타임의 동작 방식이 더 중요

### FK를 모르는 객체(영화)가 FK를 가지고 있는 객체(상영)의 컬렉션을 포함한다고 가정
- 단방향 `@OneToMany`
  - 런타임에 컬렉션의 지연 로딩과 변경 감지를 담당하는 Hibernate의 컬렉션 래퍼로 대체됨
  - JPA 구현체가 정해진 컬렉션 인터페이스와 구현체의 조합으로 래퍼를 생성하기 때문에 선언 시에 함께 초기화 하는 것이 좋음
  ``` java
  @OneToMany(cascade = CascadeType.PERSIST)
  private Collection<Screening> screenings = new ArrayList<>();
  ```
  - 컬렉션 요소를 삭제
    - 관계만 끊은 것. 레코드는 그대로 두고 FK만 null로 변경됨
    - 위 상태에서 상영만 따로 조회할 수 있는 구조라면 괜찮지만, <br />
      무조건 영화를 통해서만 상영을 조회할 수 있다면 고아 객체가 생기므로 <br />
      요소 자체를 삭제해야 함 - `orphanRemoval = true` 설정
  - 단방향 컬렉션 매핑은 엔티티를 추가할 때 많은 쿼리가 실행될 수 있음
  - 쿼리 횟수를 줄이고 싶다면? 양방향 컬렉션 매핑 사용, FK를 알고 있기 때문에 따로 업데이트가 발생하지 않음

### 값 객체 컬렉션 매핑﻿
- `@ElementCollection` - 값 객체임을 알려줌
- `@CollectionTable` - 컬렉션 테이블을 만들어줌
- 값 객체 컬렉션
  - 요소를 추가할 때에는, 원래 있던 걸 다 삭제하고 추가된 요소까지 합쳐서 다시 추가됨
  - 요소를 전체 삭제할 때에는, 단일 쿼리로 모두 삭제
- 참조 객체
  - 요소를 추가할 때에는 추가된 요소만 저장
  - 삭제는 요소만큼 삭제

## 3. 상속 매핑
- 클래스 상속 계층을 테이블에 매핑
- 상속의 용도
  - 다형적인 연관관계
  - JPA는 적절한 `SequenceCondition`, `PeriodCondition` 인스턴스 조회
  - 구체적인 클래스가 아닌 추상 클래스에만 의존 - `DiscountPolicy`는 추상클래스 `DiscountCondition`에만 의존

### 의존성 주입
- 구체적인 타입을 내부에서 직접 생성하지 않고 외부에서 생성해서 주입
- 단일 테이블 전략
  - 클래스 매핑 - `DiscriminatorValue`에 따라 불러옴
  - 다형적 쿼리 - `DiscountCondition` 타입에 따라 불러옴
  - 서브클래스 별 쿼리
  - 성능이 중요하고 상속 계층 리팩터링이 자주 발생할 경우 사용
  - 장점 - 빠른 조회 성능, 단순한 조회 쿼리
  - 단점 - nullable 제약 조건 강제 불가능, 테이블 크기가 커지면 성능이 느려질 수도 있음
- 조인 전략
  - 클래스 매핑 - `@Inheritance(strategy = InheritanceType.JOINED)`
  - 다형적 쿼리
  - 서브클래스 별 쿼리
  - 데이터 무결성이 중요하고 상속 계층이 안정적일 때 적용
  - 장점 - not null 제약조건 강제 가능, 테이블 정규화
  - 단점 - 상속 계층이 복잡한 경우 조인으로 인한 성능 저하 발생, 조회 쿼리 복잡
- 구현 클래스마다 테이블 전략
  - 클래스 매핑, 다형적 쿼리, 서브클래스 별 쿼리
  - 가급적 다른 전략 사용할 것
  - 장점 - 서브 타입을 구분해서 처리할 때 효과적, not null 제약조건 사용 가능
  - 단점 - 여러 자식 테이블을 함께 조회할 때 성능 저하, 자식 테이블을 통합해서 쿼리하기 어려움
- 상속 전략 혼합
  - 클래스 매핑, 다형적 쿼리, 서브클래스 별 쿼리
  - 상속 계층은 가급적 간단하게 유지
  - 클래스 레벨에서의 상속 계층 설계가 매핑 전략보다 더 중요
- **코드 재사용 때문에 상속을 사용하는 건 좋은 방법이 아님**
- 코드 재사용을 위한 더 좋은 방법
  - **상속보다 합성을 사용**
  - 올바른 상속의 용도 - 다형적인 연관관계
  - 올바른 상속 계층 - 특정 클래스 안에서 메서드를 구현하는 메서드는 단 하나만 존재
  - 꼭 데이터 상속을 해야 한다면 `@MappedSuperclass` 사용

## 4. 애그리게이트와 연관관계
### JPA를 사용하면서 발생하는 많은 문제의 원인과 해결
- 원인 - 객체 그룹 사이에 경계가 없어 모든 객체가 동일한 수준에서 연결
- 해결
  - 객체 그룹으로 묵어 캡슐화시킨 후 그룹 단위로 설정 적용
  - 불변식을 기준으로 그룹화 - 언제나 일관되게 유지돼야 하는 비즈니스 규칙, 불변식은 **트랜잭션 일관성**과 관련
  - 아무 객체나 접근해서 수정하거나 삭제 가능한 경우 - 특정한 객체를 통해서만 내부의 객체에 접근할 수 있도록 설정

### 애그리게이트 (AGGREGATE) - 캡슐화의 단위
- 루트와 경계가 있음
- 경계는 무엇이 포함되고 포함되지 않는지를 정의함
- 루트는 단 하나만 존재하며, 포함된 특정 엔티티를 가리킴
- 비록 경계 안의 객체들은 서로 참조할 수 있지만, 경계 바깥의 객체들은 구성요소 중 루트만 참조할 수 있음
- 불변식을 만족시키는 객체 그룹 단위로 처리
- 경합 지점의 경계 - 이런 문제는 도메인을 심도 있게 이해해야 하며, 특정 클래스 인스턴스 사이의 변화 빈도와 같은 것까지 이해 범위를 넓혀야 할 수도 있음
- **경합이 높은 지점을 느슨하게 하고, 엄격한 불변식을 보다 엄격하게 지켜지게 하는 모델을 찾아야 함**
- 불변식과 함께 동시에 접근되는 객체의 단위를 기준으로 선정 - 객체 그룹에 접근하는 시점과 클라이언트에 따라 애그리게이트 선택
- 애그리게이트 전체에 걸친 불변식 유지 - 루트가 경계 내부에 포함된 모든 객체들의 불변식 적용
- 트랜잭션의 단위, 데이터 저장/조회의 단위
- 생명주기 - 애그리게이트 전체는 함께 저장되고, 수정되고, 삭제됨
- JPA 영속성 전파 설정 - `CascadeType.ALL`
- 공유 참조와 배타적 소유권
  -  외부의 애그리게이트 루트는 서로 다른 애그리게이트가 공유
  -  애그리게이트 내부의 요소는 하나의 루트에 종속 - 관계가 끊기면 삭제 (`orphanRemoval = true` 설정)

### 연관관계 단순화하기
- 탐색 방향 부여하기 - 양방향보단 단방향
- 다중성 줄이기 - 일대다보단 다대일
- 중요하지 않은 연관관계 제거하기
- 애그리게이트 내부에서는 규칙 완화 + 애그리게이트 사이 연관관계를 더 엄격하게

## 5. 컬렉션과 지연 로딩
### 컬렉션 로딩 관련 두 가지 문제
- 즉시 로딩과 데카르트 곱 문제 
- 지연 로딩과 N+1 문제

### 지연 로딩으로 설정된 백과 셋에 요소 추가
- 백 (Bag)
  - 지연 로딩 
    - 양방향 매핑의 경우
    - 컬렉션을 로딩하지 않고 요소 추가
    - 단방향 매핑의 경우 항상 컬렉션 로딩
  - 즉시 로딩 - 다른 컬렉션과 조인 불가
- 셋 (Set)
  - 지연 로딩 
    - 단방향/양방향 매핑 모두
    - 컬렉션 로딩 후 요소 추가 (중복 체크를 위해서 로딩 먼저 함)
  - 즉시 로딩 - 다른 컬렉션과 조인 가능
 
## 6. 로딩 문제 해결하기
- 지연로딩 N+1 문제 해결
  - 일괄 페치 - 데이터 전체가 필요한지 확신할 수 없을 때 동일한 SELECT를 사용해서 필요할 때마다 일부 데이터만 로드
  - 서브쿼리 - 데이터 전체를 조회할 경우 서브쿼리를 이용해서 데이터 로드
- 즉시로딩 데카르트 곱 문제 해결
  - 다중 SELECT - JOIN 대신 추가 SELECT를 이용해 데이터를 즉시 로드
- 동적인 로딩 범위 지정
  - 엔티티 설정이 JPQL 실행에 항상 적용되는 문제
  - JPQL 실행 후 JPA 설정 적용 - 엔티티에 JPQL을 설정하면 무조건 JPQL 설정이 먼저 실행되고 JPA 설정이 실행됨
  - 전역 LAZY 설정을 무시할 수 있는 두 가지 방법
    - JPQL 페치 조인 - EAGER 설정은 무시되지 않음
    - 엔티티 그래프 - 엔티티 조회 시점에 함께 조회할 엔티티를 동적으로 지정
      - `javax.persistence.fetchgraph` - 엔티티 그래프에 명시된 경로만 로드
      - `javax.persistence.loadgraph` - 엔티티 그래프에 명시된 경로를 로드한 후 EAGER로 설정된 경로를 별도 쿼리로 조회
     
## 7. 동시성 제어 
- 동시성 문제 - 하나의 데이터를 프로세스나 스레드와 같은 에이전트가 동시에 접근할 때 발생하는 문제
  - 손실된 업데이트 - 동시에 수정할 때 나중에 수정된 데이터만 살아남음
  - 더티 읽기 - 커밋되지 않은 데이터가 조회됨
  - 반복 불가능한 읽기 - 하나의 트랜잭션 안에서 서로 다른 값 조회
  - 팬텀 읽기 - 하나의 트랜잭션 안에서 추가된 새로운 요소 조회
- 해결 방법
  - 트랜잭션 격리 수준 설정
    - `READ_UNCOMMITED` - 손실된 업데이트 방지, 정확성이 낮음
    - **`READ_COMMITED` - 손실된 업데이트, 더티 읽기 방지**. 일반적으로 사용됨
    - `REPEATABLE_READ` - 손실된 업데이트, 더티 읽기, 반복 불가능 읽기 방지
    - `SERIALIZABLE` - 네 가지 문제 모두 방지, 활동성이 낮음
  - 낙관적 잠금 (잘 사용하지 않음)
    - 충돌 가능성이 높은 경우
    - 버전 관리로 먼저 업데이트한 데이터를 살림
    - 비관적 쓰기 잠금(데드락 방지) - PK 기반으로 쿼리 정렬
   
## 8. 애그리게이트 완성하기
- 저장의 단위
- 트랜잭션과 데이터 저장/조회의 단위
- 데이터 저장/조회를 위한 객체 - 리포지토리
- 애그리게이트 단위로 리포지토리 추가
- 복잡성 감소를 위한 ID를 이용한 참조

### 연관관계와 탐색 가능성 - 연관관계는 한 객체를 통해 다른 객체에 닿을 수 있음을 의미
- 객체 참조를 통한 탐색 (강한 결합도)
- 제3의 객체를 통한 탐색 (약한 결합도)
- 리포지토리는 연관관계를 해결해줌
  - 애그리게이트 외부는 리포지토리를 통해 탐색
  - 애그리게이트끼리는 관계를 끊는 것이 좋음
  - 애그리게이트 내부는 객체 참조를 통해 탐색
- 애그리게이트 루트에 엔티티 그래프 설정
- 페치 옵션은 LAZY로 설정 (**그렇다고 무지성 LAZY를 하라는 것이 아님! 생각하고 사용!!**)
- 리포지토리 인터페이스에서 엔티티 그래프 사용
- 단순 데이터 조회는 애그리게이트가 아님, 애그리게이트는 수정용
  - 단순 데이터 조회를 위한 별도의 모델 사용
  - 트랜잭션 스크립트 패턴으로 구현
  - 데이터 조회를 위한 DAO를 별도 인터페이스로 추가
  - 데이터 조회를 위한 리포지토리 인터페이스 추가
  - JPQL로 엔티티 로드 후 엔티티를 DTO로 매핑
  - 네이티브 쿼리 실행 후 DTO에 매핑
- **트랜잭션 스크립트와 JPA - 비슷한 형태의 객체와 테이블 변환, SQL 자동화**
- **도메인 로직과 JPA - 임피던스 불일치 해결**
