---
layout: single
title: "[우테코] 프리코스 6기 3주차 - 로또"
categories:
  - education
sidebar:
  nav: "sidebar-category"
---

> [3주차 로또](https://github.com/woowacourse-precourse/java-lotto-6)

> [내 PR 주소](https://github.com/woowacourse-precourse/java-lotto-6/pull/537)

 
💡이번주의 목표!

1. 협력 -> 행동 -> 정보 -> 메세지 순으로 객체 설계!
2. MVC 패턴 구현!! 해봐!!!
3. enum 사용
4. 예외 클래스 나누기


### ✅ README.md

🎮 게임 진행 과정
- 구매할 로또 금액 입력 (1000원 단위)
- 당첨 번호 임력 (쉼표로 구분)
- 보너스 번호 입력
- 발행한 로또 수량 및 번호 출력 (로또 번호를 오름차순 정렬)
- 당첨 내역 출력
- 수익률 출력 (소수점 둘째 자리에서 반올림)
- 예외 상황 시 에러 문구 출력 (`[ERROR]`로 시작)

### ✅ 규칙
- 로또 번호의 숫자 범위는 1~45
- 1개의 로또에서는 중복되지 않는 6개의 숫자
- 당첨 번호 추첨 시 중복되지 않는 숫자 6개 + 보너스 번호 1개
- 당첨은 1등~5등
- 당첨 기준
  - 1등: 6개 번호 일치 / 2,000,000,000원
  - 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
  - 3등: 5개 번호 일치 / 1,500,000원
  - 4등: 4개 번호 일치 / 50,000원
  - 5등: 3개 번호 일치 / 5,000원


### ⚙️ 구현 기능
Model
- 로또 번호
  - 로또 번호 예외 검사
    - 1~45 사이의 수
    - 중복 불가
    - 6개의 숫자
    - 숫자
  - 당첨 번호와 일치하는 번호의 개수 반환
  - 보너스 번호 유무 확인
  - 로또 번호 오름차순 정렬
- 로또 진행
  - 구입 금액 예외 검사
    - 1000원 단위의 금액
  - 보너스 번호 예외 검사
    - 1~45 사이의 수
    - 중복 불가
    - 숫자
  - 구입 금액만큼 로또 번호 생성
  - 랜덤 번호 생성
- 당첨자 확인
  - 당첨 여부 확인
  - 당첨 결과 (enum 사용)
View
- 사용자 입력
  - 구입 금액
  - 당첨 번호
  - 보너스 번호
- 결과 출력
  - 구매 개수
  - 로또 번호 목록
  - 당첨 통계
  - 수익률
Controller
- 게임 시작


### ✅ 테스트 코드
저번주에는 단순 메서드 확인이라서 엄청 어렵게 느껴졌었는데, 한번 해보기도 했고 확실하게 행동으로 메서드를 나누고 나니까<br />
테스트 코드를 만드는 데에 저번보단 어려움이 적었다.<br />
처음에 요구사항을 잘못 이해해서.. `InputView`에서 구입금액, 보너스 번호에 대한 예외 처리를 다 해버렸따...<br />
요구사항 제대로 꼼꼼히 읽어보니까 모델만 테스트하고 모델에서만 예외처리를 해야되길래 바꿔줬다.


### ✅ 새로운 사용

#### enum

`enum`은 저번 미션 때 그냥 단순클래스로 분리해서 사용했던 매직변수들과 에러 메세지, 로또 당첨금 목록 등에 사용했다.<br />
저번에 모든 변수들을 `public`으로 지정하고 가져다가 쓰는 게 계속 맘에 걸렸는데,<br />
이런 방법으로 하니까 완벽하게 보호된 건 아니지만 저번보단 ... 보호해준 것 같다 나의 소중한 매직변수들...

``` java 
public enum MagicVariable {
    NUMBERS_SIZE(6),
    NUMBERS_MIN_RANGE(1),
    NUMBERS_MAX_RANGE(45),
    NONE_PURCHASE_PRICE(0),
    LOTTO_PRICE(1000);

    private final int number;

    MagicVariable(int number) {
        this.number = number;
    }

    public int getNumber() {
        return number;
    }
}
```

#### 예외 클래스 분리

`Exception`도 `IllgerArgumentException`을 상속받아서 구현해야된다는 게 저저번주만 해도 이해가 잘 안됐는데,<br />
이런 식으로 하니까 기존에 해당 클래스 안에 예외 메서드들을 나열해줬던 것보다 훨씬 보기 깔끔해졌다.

``` java
public class LottoException extends IllegalArgumentException {
    private LottoException(String message) {
        super(message);
    }

    public static void checkNumbersException(List<Integer> numbers) {
        checkNumbersSizeException(numbers);
        checkNumbersDuplicationException(numbers);
        checkNumbersRangeException(numbers);
    }

    private static void checkNumbersSizeException(List<Integer> numbers) {
        if (numbers.size() != NUMBERS_SIZE.getNumber()) {
            throw new LottoException(NUMBERS_SIZE_ERROR_MESSAGE.getErrorMessage());
        }
    }
    ... 중략
}

public Lotto(List<Integer> numbers) {
    LottoException.checkNumbersException(numbers);
    this.numbers = numbers;
}
```

#### MVC패턴 적용

코드리뷰를 하면서 남들보다 너무 수준이 낮은 거 아닐까 하는 생각에 주눅들어서 그런지 전에는 MVC패턴으로 구현은 커녕 리팩토링을 하려해도 너무너무 어려웠는데, 오수타와 코수타를 참여하고 부담이 좀 덜어져서..! 그래!! 나는 내 속도만 생각하자! 하니까 오히려 금방했다!<br />
모델 객체에 대한 테스트를 꼼꼼하게 하니까, 객체들의 역할들을 더 잘 구분할 수 있게 된 거 같다.<br />
처음에는 예외처리를 `InputView`에서 해줬는데, 요구사항을 읽어보니 다 모델에서 해야하는 것 같았다.<br />
그래서 다시 생각해보면, 내가 `InputView`에서는 입력만 받는 건데 역할을 잘못 준 거라는 걸 깨달았다...!<br />
근데 이게 스트링으로 입력 받고 나서 숫자인지 확인하고 숫자에대한 예외검사를 또 확인해야되는데, 입력 받고나서....인데 어떻게 모델 내에서 하지?? 하다가 처음에는 컨트롤러에서도 예외검사를 했었는데 두 번 하는 게 맘에 계속 걸려서 입력값에 대한 타입검사(문자열이 아닌 양수인지)를 따로 메서드로 빼고 그걸 호출해서 숫자를 받아와줬다.

``` java
public int isValidBonusNumber(String userBonusNumber, List<Integer> winningNumbers) {
    int bonusNumber = getBonusIntegerNumber(userBonusNumber);
    WinningLottoException.checkBonusNumberIntegerExceptions(winningNumbers, bonusNumber);
    return bonusNumber;
}

private static int getBonusIntegerNumber(String userBonusNumber) {
    WinningLottoException.checkBonusNumberTypeException(userBonusNumber);
    return Integer.parseInt(userBonusNumber.trim());
}
```

여기서 한참 문자를 입력했을 때 For Input String : "aa" 이런 에러문구가 뜨고 안잡혔는데, 입력값 자체를 바로 리턴하게 바꿔주니까 해결됐다! 저것만 두시간 넘게 찾은듯 ㅠㅠㅠ 

``` java
public int getBonusNumber(List<Integer> winningLotto) {
    System.out.println("보너스 번호를 입력해 주세요.");
    String userBonusNumber = Console.readLine();
    return Integer.parseInt(userBonusNumber.trim());
}

// -------- 이미 Integer로 넘겨줘서 String일 때는 아예 인식을 못함 --------

public String getBonusNumber(List<Integer> winningLotto) {
    System.out.println("보너스 번호를 입력해 주세요.");
    return Console.readLine();
}
```

#### 에러 메세지 출력 및 재입력 표시

그리고 반드시 통과해야될 Application Test - 예외_테스트() 가 분명 에러메세지는 맞게 나오는데 계속 에러가 떠서ㅠㅠ<br />
찾아보니까!! 이번에는 `try~catch` 문으로 메세지를 보여줘야 되는 걸 유도한 것 같다.<br />
근데 이걸 바보처럼 해당 에러 메세지가 표시되는 InputView 내에서 처리해주다가, 요구사항을 다시 읽어보니까 그게 아니라 전체적으로 그렇게 표시되어야하는 것 같길래, 컨트롤러 메서드마다 추가해줬다.<br />
BUT 이게 끝인줄 알았으나 놓친 부분이 있었다..!! 큰일날뻔 ㅠ ㅠ<br />
이렇게 메세지 출력만이 아니라, 다시 그 부분부터 입력을 받아야 되길래 컨트롤러 전체 메서드에 `while-try-catch`로 처리해줬다!

``` java
public void run() {
    int purchaseAmount = getValidPurchaseAmount();
    List<Lotto> purchaseLotto = getValidPurchaseLotto(purchaseAmount);
    WinningLotto winningLotto = getValidWinningLotto();

    outputView.showPrizeResult(purchaseLotto, winningLotto, purchaseAmount);
}

private int getValidPurchaseAmount() {
    while (true) {
        try {
            String userPurchaseAmount = inputView.getPurchaseAmount();
            return lottoProcess.purchaseAmount(userPurchaseAmount);
        } catch (LottoProcessException e) {
            System.out.println(e.getMessage());
        }
    }
}
... 중략
```

이걸 하는 과정에서 보너스 번호 예외를 놓친 걸 알았는데, 보너스 번호 중복 검사는 로또 번호를 받고 나서 해야돼서... 꽤나 애먹었다ㅠ<br />
그래서 결국 로또클래스에서 게터를 생성하고 당첨 번호를 받아와서 보너스 번호 중복 검사를 해줬다!

``` java
public List<Integer> getNumbers() {
    return new ArrayList<>(numbers);
}
```


### ✅ 소감

미션이 나오기 전에 저번 미션보다 나아질 내 모습을 생각하면 어떤 걸 목표로 둬야할까 생각해봤다.<br />
저번 미션에 객체지향을 목표로 한다고 했지만 객체지향에 대해 공부할수록 저번주의 미션은 객체지향적인 구현과는 거리가 멀었다고 생각했고, 이걸 보완하려면 MVC패턴의 규칙을 지키면서 기능 구현에 신경쓰면 객체지향에 대해서도 감이 올 거 같아서 MVC패턴으로 꼭 구현해봐야지 생각했다... 어려워서 미루기만 했던 것..<br />
<br />
또한 다른 분들의 코드를 리뷰하면서 `enum`을 사용해야겠다고 생각했고, 기존에는 예외처리도 사용자 입력에서 단순 메서드로만 분리했었는데 따로 클래스로 분리해야겠다고 생각했다! 사용해보니까 `enum`이 정말정말 편하구나, 매직변수들에 대한 접근제어자에 대한 고민들도 `enum`을 사용하니까 삭 사라졌다.<br />
<br />
확실히 객체들의 행동으로 클래스를 구분하니까 예외도 클래스마다 적절하게 분리되었고, 테스트도 깔끔하게 할 수 있던 것 같다.<br />
하지만.... UI에 대한 출력 테스트도 다 진행했었는데 요구사항에 제외인 걸 뒤늦게 확인하고 눈물흘리며 삭제...<br />
다음 미션 때는 요구사항을 더 꼼꼼히 봐야겠다 진짜 진짜 꼼꼼히 진짜진짜로<br />
<br />
그리고 처음에는 게터, 세터 없이 어떻게...!! 불러쓰라는 거야! 싶었는데<br />
객체마다 생성자를 활용해서 컨트롤러에서 해당 객체를 바로 만들 수 있게 하니까 게터, 세터 함수를 쓰지 않고 호출할 수 있었다!<br />
하지만 결국엔 보너스번호를 불러오는 과정에서 중복검사를 때문에 만들어 썼지만, 이런 특수한 상황 말고는 객체 자체를 게터 없이 불러올 수 있는 방법을 알게 됐다. 책을 읽으면서도 계속 띠용띠용 했던 게 직접 구현하면서 해결됐다(감격)
